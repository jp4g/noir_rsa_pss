{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":6219865386057728221,"abi":{"parameters":[{"name":"hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"signature_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"private"},{"name":"modulus_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"private"},{"name":"redc_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"private"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"26":{"source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// docs:start:sha256\n#[deprecated(\"sha256 is being deprecated from the stdlib, use https://github.com/noir-lang/sha256 instead\")]\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\n#[deprecated(\"sha256 is being deprecated from the stdlib, use https://github.com/noir-lang/sha256 instead\")]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\n#[deprecated(\"sha256 is being deprecated from the stdlib, use https://github.com/noir-lang/sha256 instead\")]\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        // Safety: the msg_block is checked below in verify_msg_block\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        // Safety: the msg_block is checked below in verify_msg_block\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    // Safety: the msg_len is checked below in verify_msg_len\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::{\n        attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n        set_item_byte_then_zeros, set_item_zeros,\n    };\n    use super::INT_BLOCK;\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n\n    #[test]\n    fn test_get_item_byte() {\n        let fld = make_item(10, 20, 30, 40);\n        assert_eq(fld, 0x0a141e28);\n        assert_eq(get_item_byte(fld, 0), 10);\n        assert_eq(get_item_byte(fld, 4), 10);\n        assert_eq(get_item_byte(fld, 6), 30);\n    }\n\n    #[test]\n    fn test_byte_into_item() {\n        let fld = make_item(0, 20, 0, 0);\n        assert_eq(byte_into_item(20, 1), fld);\n        assert_eq(byte_into_item(20, 5), fld);\n    }\n\n    #[test]\n    fn test_set_item_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 0, 0, 0);\n        assert_eq(set_item_zeros(fld0, 3), fld1);\n        assert_eq(set_item_zeros(fld0, 4), 0);\n        assert_eq(set_item_zeros(0, 4), 0);\n    }\n\n    #[test]\n    fn test_set_item_byte_then_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 50, 0, 0);\n        assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_0() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48,\n        ];\n        assert_eq(input.len(), 22);\n\n        // Safety: testing context\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 0) };\n        assert_eq(msg_byte_ptr, input.len());\n        assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n        assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n        assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n        assert_eq(msg_block[6], 0);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_1() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        assert_eq(input.len(), 68);\n        // Safety: test context\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 64) };\n        assert_eq(msg_byte_ptr, 4);\n        assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n        assert_eq(msg_block[1], 0);\n    }\n\n    #[test]\n    fn test_attach_len_to_msg_block() {\n        let input: INT_BLOCK = [\n            2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n            1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n            1849316213, 1651139939,\n        ];\n        // Safety: testing context\n        let msg_block = unsafe { attach_len_to_msg_block(input, 1, 448) };\n        assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n        assert_eq(msg_block[1], 0);\n        assert_eq(msg_block[15], 3584);\n    }\n}\n","path":"std/hash/sha256.nr"},"61":{"source":"use bignum::params::BigNumParams;\nuse rsa::{rsa::verify_sha256_pss, types::RBN2048};\n\n// Examples of the signature limbs, modulus, and redc params can be generated via\n// ../../signature_gen/main.rs.\n// Note: technically, the `signature` could've been passed into `main` directly,\n// for a much cleaner interface.\n// The reason we chose this more verbose approach here, was to reduce the amount of\n// data to generate for the Prover.toml file.\nfn main(\n    hash: [u8; 32],\n    signature_limbs: [u128; 18],\n    modulus_limbs: [u128; 18],\n    redc_limbs: [u128; 18],\n) {\n    let has_multiplicative_inverse = false;\n    let params: BigNumParams<18, 2048> =\n        BigNumParams::new(has_multiplicative_inverse, modulus_limbs, redc_limbs);\n\n    let signature: RBN2048 = RBN2048::from_array(params, signature_limbs);\n\n    assert(verify_sha256_pss(hash, signature, 2048));\n}\n\n#[test]\nfn test_main() {\n    // Output of `cargo run -- --msg \"hello world\"` in the `signature_gen` directory\n    // Create runtime params:\n    let modulus_limbs = [\n        0x83e879145bffccbe4d783abeca8999,\n        0xb7d9868f5b915b43f6c6a8193a1a4f,\n        0x67f95badedef107f0998ab3d52961e,\n        0x7dcc9780ac8d71c6b49bbfeca25f0,\n        0xf9fdced289a3d4f62830681be65b50,\n        0x986aa8fe98888e9f609af97515b036,\n        0xd494bc65f4608849a6ed8cf5cb82ed,\n        0x18ca508b8353e676387d22667e4adb,\n        0x9d3fcb816b4763099ccbb7416a7ad,\n        0xcfd89fee1ffcfa5f2243c92e3908b7,\n        0xcaf320fbb34158238b41042f9c6386,\n        0xb3df0cd5dee269ecec61b342880c59,\n        0x2134236dc67b59df001cac48181625,\n        0x536d424ce3dcaf2b3c15eba3ceb98,\n        0x7c6532647de2f025c4245c4a816ea9,\n        0x1ca6b6ac38706f61dd460c53293c88,\n        0x812b9256f612815edb22ec614a6c89,\n        0xc9,\n    ];\n    let redc_limbs = [\n        0x9ec08341171d384b92ed35848dac43,\n        0xaa5e7059598102ad1d99f33e533781,\n        0x894978a6e54a780efd6c579b74dd3f,\n        0x9531219036eb346dc4d2f142d9aeb3,\n        0x2d67220edac65500daea360896b937,\n        0x72393de3ce76a185b8d5fe4efeb301,\n        0x2e5a676dc2d3d971ead0a1a8127ff1,\n        0xbb92e11f4b88fb1f478a8e5fcc8a63,\n        0x978205931de77dc276cbffcfa9ab06,\n        0x3f0074f27a70de9b87b38923c5d26f,\n        0x315d3964500ad7da70267bebb13aed,\n        0xee04558c06aced97c3375cb93ae624,\n        0xcaf9c90ec5317baf27dabd3f3a6018,\n        0x453a832dd0cf10c2e7669123ffdabe,\n        0xc6c46372e3eda40f2582e2e9902867,\n        0xcdb6b9ecb85a01524cbe4cee82a2c2,\n        0xbbaa5920d526e092f29b41b1c629e1,\n        0x1453,\n    ];\n\n    let signature_limbs = [\n        0x2e3f7f3a3b7d89cbf680adcee4f039,\n        0xcca286445a216e1c110416099710f3,\n        0x0684d04d7773fbff2223360e314f47,\n        0x1342e7d3f7cadd18ba5f0ed57b1e54,\n        0xe5347fc80630780900cffe3d20cb7d,\n        0xda578cadd719f2a38f505d54c46203,\n        0x4a729fdd97383a0e32b5e8f671c833,\n        0x810ea2ce9ace9bd072bd3b221c9b62,\n        0xc565d6bff72c8501a729ecab2aee3b,\n        0xe042b627c4e6b4cc6ab4ca0ababaaa,\n        0x8e707750c71a4f9f0b9d9389b61826,\n        0x850297f956c58dafb6bf4f7bb049fa,\n        0x32c51e7454edae060725c509d9a48c,\n        0xbe2f1df6227e67dc61e6ab82bc501f,\n        0xea17c90cc7053bbb94ddfac6b1a405,\n        0x6c6eaada9c24dfa1a476c3718f6735,\n        0x0134b376c64ba2a79a086061573792,\n        0x22,\n    ];\n\n    // let hash: [u8; 32] = dep::std::hash::sha256(\"hello world\".as_bytes());\n    // hash of the jwt\n    let hash: [u8; 32] = [\n        190, 196, 184, 50, 102, 89, 57, 43, 211, 245, 140, 168, 170, 163, 80, 128, 25, 139, 25, 68,\n        239, 215, 154, 164, 148, 234, 47, 212, 6, 140, 157, 110,\n    ];\n\n    main(hash, signature_limbs, modulus_limbs, redc_limbs);\n}\n","path":"/Users/ianbrighton/Documents/Mach34/open_banking/noir_rsa_pss/example_pss/src/main.nr"},"96":{"source":"use crate::constants::TWO_POW_120;\nuse crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__add, __div, __mul, __neg, __sub, __udiv_mod},\n};\nuse crate::params::BigNumParams as P;\nuse std::cmp::Ordering;\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n * gt \n * check_gt_with_flags\n */\n\npub(crate) fn limbs_to_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    limbs: [u128; N],\n) -> Field {\n    if N > 2 {\n        // validate that the limbs is less than the modulus the grumpkin modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, MOD_BITS>(grumpkin_modulus, limbs);\n        // validate that the limbs are in range\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n    }\n    // validate the limbs sum up to the field value\n    if N < 2 {\n        limbs[0] as Field\n    } else if N == 2 {\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n        (limbs[0] + limbs[1] * TWO_POW_120) as Field\n    } else {\n        // validate_in_range::<N, 254>(limbs);\n        (\n            limbs[0] as Field\n                + limbs[1] as Field * TWO_POW_120 as Field\n                + limbs[2] as Field * TWO_POW_120 as Field * TWO_POW_120 as Field\n        )\n    }\n}\n\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(field: Field) -> [u128; N] {\n    // Safety: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result: [u128; N] = unsafe { __from_field::<N>(field) };\n    if !std::runtime::is_unconstrained() {\n        // validate the limbs are in range and the value in total is less than 2^254\n\n        // validate that the last limb is less than the modulus\n        if N > 2 {\n            // validate that the result is less than the modulus\n            let mut grumpkin_modulus = [0; N];\n            grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n            grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n            grumpkin_modulus[2] = 0x3064;\n            validate_gt::<N, MOD_BITS>(grumpkin_modulus, result);\n            // validate that the limbs are in range\n            validate_in_range::<_, N, MOD_BITS>(result);\n        }\n        // validate the limbs sum up to the field value\n        let TWO_POW_120_FIELD = TWO_POW_120 as Field;\n        let field_val = if N < 2 {\n            result[0] as Field\n        } else if N == 2 {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field + result[1] as Field * TWO_POW_120_FIELD\n        } else {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field\n                + result[1] as Field * TWO_POW_120_FIELD\n                + result[2] as Field * TWO_POW_120_FIELD * TWO_POW_120_FIELD\n        };\n        assert_eq(field_val, field);\n    }\n\n    result\n}\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\n\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        std::hash::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[u128; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [u128; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n        let mut num_remaining_limbs =\n            (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n        let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n        let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n            + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n        for j in 0..num_limbs_in_bigfield {\n            let mut limb: u128 = 0;\n            for _ in 0..15 {\n                let need_more_bytes = (byte_ptr < num_bytes);\n                let mut byte = hash_buffer[byte_ptr];\n                limb *= (256 * need_more_bytes as u128 + (1 - need_more_bytes as u128));\n                limb += byte as u128 * need_more_bytes as u128;\n                byte_ptr += need_more_bytes as u32;\n            }\n            bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n        }\n        bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n    }\n\n    let mut bigfield_rhs_limbs: [u128; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, _, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [u128; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        // result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n\n    result\n}\n\n/**\n* @brief conditional_select given the value of `predicate` return either `self` (if 0) or `other` (if 1)\n* @description should be cheaper than using an IF statement (TODO: check!)\n**/\npub(crate) fn conditional_select<let N: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n    predicate: bool,\n) -> [u128; N] {\n    let mut result: [u128; N] = lhs;\n    for i in 0..N {\n        // (lhs[i] - rhs[i]) * predicate + rhs[i]\n        // in case lhs < rhs, this will underflow so we have to do one extra multiplication to prevent it\n        result[i] = lhs[i] * predicate as u128 + rhs[i] * (1 - predicate as u128);\n    }\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    for i in 0..N {\n        l *= TWO_POW_120 as Field;\n        r *= TWO_POW_120 as Field;\n        modulus_mod_n *= TWO_POW_120 as Field;\n        l += lhs[N - i - 1] as Field;\n        r += rhs[N - i - 1] as Field;\n        modulus_mod_n += params.modulus[N - i - 1] as Field;\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let diff = l - r;\n    let target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let is_equal_modulus: bool = diff == params.modulus;\n    let is_equal_zero: bool = diff.all(|elem| elem == 0);\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn is_zero<let N: u32, let MOD_BITS: u32>(val: [u128; N]) -> bool {\n    val.all(|limb| limb == 0)\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [u128; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = (modulus[i] as Field - val[i] as Field);\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    p_minus_self[0] += (borrow_flags[0] as Field * TWO_POW_120 as Field);\n    for i in 1..N - 1 {\n        p_minus_self[i] +=\n            (borrow_flags[i] as Field * TWO_POW_120 as Field - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= (borrow_flags[N - 2] as Field);\n    validate_in_range::<_, _, MOD_BITS>(p_minus_self);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<T, let N: u32, let MOD_BITS: u32>(limbs: [T; N])\nwhere\n    T: Into<Field>,\n{\n    for i in 0..(N - 1) {\n        limbs[i].into().assert_max_bit_size::<120>();\n    }\n\n    limbs[N - 1].into().assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [u128; N]) {\n    for i in 0..(N) {\n        (limbs[i] as Field).assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    (limbs[N - 1] as Field).assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (underflow, result, carry_flags, borrow_flags) =\n        unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, _, MOD_BITS>(result);\n    assert(!underflow, \"BigNum::validate_gt check fails\");\n    check_gt_with_flags::<N, MOD_BITS>(lhs, rhs, result, borrow_flags, carry_flags);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __neg(params, val)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, borrow_flags) = unsafe { __neg_with_flags(params, val) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n        let result_limb = modulus[0] + (borrow_flags[0] as u128 * TWO_POW_120) - val[0] - result[0];\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = modulus[i] + (borrow_flags[i] as u128 * TWO_POW_120)\n                - val[i]\n                - result[i]\n                - borrow_flags[i - 1] as u128;\n            assert(result_limb == 0);\n        }\n        let result_limb = modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as u128;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            // __add_u128(params, lhs, rhs)\n            __add(params, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, carry_flags, borrow_flags, overflow_modulus) =\n            unsafe { __add_with_flags(params, lhs, rhs) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut subtrahend: [u128; N] = [0; N];\n        if (overflow_modulus) {\n            subtrahend = modulus;\n        }\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = lhs[0] as Field + rhs[0] as Field\n            - subtrahend[0] as Field\n            - result[0] as Field\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] as Field + rhs[i] as Field\n                - subtrahend[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120 as Field;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = lhs[N - 1] as Field + rhs[N - 1] as Field\n            - subtrahend[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __sub(params, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        // a - b = r\n        // p + a - b - r = 0\n        let (result, carry_flags, borrow_flags, underflow) =\n            unsafe { __sub_with_flags(params, lhs, rhs) };\n\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut addend: [u128; N] = [0; N];\n        if (underflow) {\n            addend = modulus;\n        }\n\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n            + addend[0] as Field\n            + lhs[0] as Field\n            - rhs[0] as Field\n            - result[0] as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n                + addend[i] as Field\n                + lhs[i] as Field\n                - rhs[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = addend[N - 1] as Field + lhs[N - 1] as Field\n            - rhs[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[lhs]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [result],\n            [true],\n        );\n    }\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[result]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [lhs],\n            [true],\n        );\n    }\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n    if !std::runtime::is_unconstrained() {\n        // self / divisor = quotient rounded\n        // quotient * divisor + remainder - self = 0\n        evaluate_quadratic_expression(\n            params,\n            [[quotient]],\n            [[false]],\n            [[divisor]],\n            [[false]],\n            [numerator, remainder],\n            [true, false],\n        );\n        // we need (remainder < divisor)\n        // implies (divisor - remainder > 0)\n        validate_gt::<_, MOD_BITS>(divisor, remainder);\n    }\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n\n// a comparison function. returns true if lhs > rhs and false otherwise\npub(crate) fn cmp<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) -> Ordering {\n    let (underflow, result, carry_flags, borrow_flags) =\n        unsafe { __validate_gt_remainder(lhs, rhs) };\n    // if underflow is true, swap lhs and rhs\n    let (lhs, rhs) = if underflow { (rhs, lhs) } else { (lhs, rhs) };\n    check_gt_with_flags::<N, MOD_BITS>(lhs, rhs, result, borrow_flags, carry_flags);\n    if lhs == rhs {\n        Ordering::equal()\n    } else if underflow {\n        Ordering::less()\n    } else {\n        Ordering::greater()\n    }\n}\n\n// the constraining function for the results returned by __validate_gt_remainder. this is used in both comparisons and validate gt\npub(crate) fn check_gt_with_flags<let N: u32, let MOD_BITS: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n    result: [u128; N],\n    borrow_flags: [bool; N],\n    carry_flags: [bool; N],\n) {\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] as Field - rhs[0] as Field + addend[0] - result[0] as Field - 1\n        + (borrow_flags[0] as Field - carry_flags[0] as Field) * TWO_POW_120 as Field;\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n        let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n        let result_limb = lhs[i] as Field - rhs[i] as Field + addend[i] as Field\n            - result[i] as Field\n            - prev_borrow_sub_carry\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] as Field - rhs[N - 1] as Field + addend[N - 1] as Field\n        - result[N - 1] as Field\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n","path":"/Users/ianbrighton/nargo/github.com/noir-lang/noir-bignum/v0.6.1/src/fns/constrained_ops.nr"},"97":{"source":"use crate::utils::split_bits;\n\nuse crate::constants::{TWO_POW_120, TWO_POW_126, TWO_POW_246};\nuse crate::fns::{\n    constrained_ops::validate_quotient_in_range, unconstrained_helpers::__barrett_reduction,\n};\nuse crate::params::BigNumParams as P;\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\n\nunconstrained fn __compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N], [Field; 2 * N - 2]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut mulout_p = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let (quotient, remainder) =\n        __barrett_reduction(relation_result, params.redc_param, MOD_BITS, params.modulus);\n    assert(remainder == [0; N]);\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] as Field * params.modulus[j] as Field;\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N - 2] = [0; 2 * N - 2];\n    let borrow_shift: Field = TWO_POW_246; // 2^{246}\n    let borrow_carry: Field = TWO_POW_126; // 2^{246 - 120} = 2^{126}\n    let downshift: Field = 1 / (TWO_POW_120 as Field);\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits =\n        (mulout_p[0] - mulout_n[0] + (borrow_flags[0] as Field * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field =\n            mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (\n            mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n                - (borrow_flags[i - 1] * borrow_carry)\n        )\n            * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n    flags: [bool; M],\n) -> ([u128; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [u128; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [u128; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + (modulus2[j] as Field - x[i][j] as Field) as u128;\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn __compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[u128; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[u128; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [u128; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] as Field * rhs[k][j] as Field);\n            }\n        }\n        mulout[i] += add[i] as Field;\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\npub(crate) unconstrained fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout: [Field; (N * 2)] = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) =\n        __barrett_reduction(relation_result, params.redc_param, k, params.modulus);\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([u128; N], [u128; N], [Field; 2 * N - 2]) = unsafe {\n        __compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [u128; N] = params.double_modulus;\n\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i] as Field;\n                    t0[k][i] += double_modulus[i] as Field;\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i] as Field;\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i] as Field;\n                    t1[k][i] += double_modulus[i] as Field;\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i] as Field;\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i] as Field;\n                t4[i] += double_modulus[i] as Field;\n            } else {\n                t4[i] += linear_terms[j][i] as Field;\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term =\n                        t0[k][i] * t1[k][j] - quotient[i] as Field * params.modulus[j] as Field;\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j] as Field;\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] as Field * params.modulus[j] as Field;\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size::<1>();\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size::<1>();\n        product_limbs[i] += (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] as Field * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n","path":"/Users/ianbrighton/nargo/github.com/noir-lang/noir-bignum/v0.6.1/src/fns/expressions.nr"},"99":{"source":"/**\n* @brief construct a BigNum instance out of an array of bytes in BIG ENDIAN format\n* @description: each 120-bit limb represents 15 bytes, we require that the size of the byte array\n*               is precisely large enough to cover MOD_BITS\n* @param x: input byte array\n**/\npub(crate) fn from_be_bytes<let N: u32, let MOD_BITS: u32, let NBytes: u32>(\n    x: [u8; NBytes],\n) -> [u128; N] {\n    let num_bits = NBytes * 8;\n    assert(num_bits >= MOD_BITS);\n    assert(num_bits - MOD_BITS < 8);\n    let mut result: [u128; N] = [0; N];\n\n    let excess_bytes = N * 15 - NBytes;\n    let final_limb_bytes = 15 - excess_bytes;\n    let mut limb: u128 = 0;\n    let mut k = 0;\n    for _j in 0..final_limb_bytes {\n        limb *= 256;\n        limb += x[k] as u128;\n        k += 1;\n    }\n    result[N - 1] = limb;\n\n    for i in 1..N {\n        let mut limb: u128 = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as u128;\n            k += 1;\n        }\n        result[N - i - 1] = limb;\n    }\n\n    let most_significant_byte: Field = x[0] as Field;\n\n    most_significant_byte.assert_max_bit_size::<8 - (NBytes * 8 - MOD_BITS)>();\n    result\n}\n\npub(crate) fn to_le_bytes<let N: u32, let MOD_BITS: u32, let NBytes: u32>(\n    val: [u128; N],\n) -> [u8; NBytes] {\n    let nbytes = (MOD_BITS / 8) + (MOD_BITS % 8 != 0) as u32;\n    assert(nbytes <= NBytes);\n\n    let mut result: [u8; NBytes] = [0; NBytes];\n    for i in 0..N - 1 {\n        let limb_bytes: [u8; 15] = (val[i] as Field).to_le_bytes();\n        for j in 0..15 {\n            result[i * 15 + j] = limb_bytes[j];\n        }\n    }\n    let last_limb_bytes: [u8; 15] = (val[N - 1] as Field).to_le_bytes();\n    let num_last_bytes = (NBytes - (N - 1) * 15);\n    for i in 0..num_last_bytes {\n        result[(N - 1) * 15 + i] = last_limb_bytes[i];\n    }\n    result\n}\n","path":"/Users/ianbrighton/nargo/github.com/noir-lang/noir-bignum/v0.6.1/src/fns/serialization.nr"},"100":{"source":"use crate::constants::{TWO_POW_119, TWO_POW_120, TWO_POW_60};\nuse crate::fns::unconstrained_ops::{__add, __gte, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\nuse crate::utils::msb::get_msb64;\nuse crate::utils::split_bits::__normalize_limbs;\n\npub(crate) unconstrained fn __from_field<let N: u32>(field: Field) -> [u128; N] {\n    let mut x = field;\n    let x_first_u128 = (x as u128);\n    let first: u128 = x_first_u128 % TWO_POW_120;\n    // this becomes the same as a integer division because we're removing the remainder\n    x = (x - (first as Field)) / (TWO_POW_120 as Field);\n    let x_second_u128 = (x as u128);\n    let second = x_second_u128 % TWO_POW_120;\n    x = (x - (second as Field)) / (TWO_POW_120 as Field);\n    let x_third_u128 = (x as u128);\n    let third = x_third_u128 % TWO_POW_120;\n    let mut result: [u128; N] = [0; N];\n    if N > 2 {\n        result[0] = first;\n        result[1] = second;\n        result[2] = third;\n    }\n    if N == 2 {\n        result[0] = first;\n        result[1] = second;\n    }\n    if N == 1 {\n        result[0] = first;\n    }\n    result\n}\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [u128; N] = params.modulus;\n    flags[0] = modulus[0] < val[0];\n    for i in 1..N - 1 {\n        flags[i] = modulus[i] < val[i] + flags[i - 1] as u128;\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> (bool, [u128; N], [bool; N], [bool; N]) {\n    let mut a = lhs;\n    let mut b = rhs;\n    let underflow = !__gte(lhs, rhs);\n\n    let mut result: [u128; N] = [0; N];\n    // swap a and b if there's an underflow\n    let (a, b) = if underflow { (b, a) } else { (a, b) };\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 1;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = a[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = b[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = (borrow * TWO_POW_120 + add_term - sub_term);\n\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry as bool;\n            borrow_flags[i] = borrow as bool;\n        }\n    }\n    (underflow, result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> ([u128; N], [bool; N - 1]) {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow_in: u128 = 0;\n\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    for i in 0..N {\n        let sub_term = val[i] + borrow_in;\n        let borrow = (sub_term > params.modulus[i]) as u128;\n        result[i] = borrow * TWO_POW_120 + params.modulus[i] - sub_term;\n\n        borrow_in = borrow;\n        if (i < N - 1) {\n            borrow_flags[i] = borrow as bool;\n        }\n    }\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N - 1], bool) {\n    let add_res = __helper_add(lhs, rhs);\n    let overflow = __gte(add_res, params.modulus);\n\n    let mut subtrahend: [u128; N] = [0; N];\n    let mut result: [u128; N] = [0; N];\n\n    if overflow {\n        subtrahend = params.modulus;\n    }\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term = lhs[i] + rhs[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry as u128;\n\n        let sub_term = subtrahend[i] + borrow_in;\n\n        let mut borrow: u128 = (sub_term > add_term) as u128;\n        result[i] = borrow * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow as u128;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry as bool;\n            if (i < N - 1) {\n                borrow_flags[i] = borrow as bool;\n            }\n        }\n    }\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N - 1], bool) {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let underflow = !__gte(lhs, rhs);\n    let addend: [u128; N] = if underflow { params.modulus } else { [0; N] };\n    let mut result: [u128; N] = [0; N];\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = lhs[i] + addend[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = rhs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = borrow as u128 * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry as bool;\n            if (i < N - 1) {\n                borrow_flags[i] = borrow as bool;\n            }\n        }\n    }\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [u128; 2 * N],\n    redc_param: [u128; N],\n    k: u32,\n    modulus: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mulout_field: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout_field[i + j] += x[i] as Field * redc_param[j] as Field;\n        }\n    }\n\n    let mulout: [u128; 3 * N] = __normalize_limbs(mulout_field, 3 * N - 1);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient = __shr(mulout, (k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n    // the quotient has bunch of zero limbs now, so we can just take the first N limbs as a result\n    let mut smaller_quotient = [0; N];\n    for i in 0..N {\n        smaller_quotient[i] = quotient[i] as u128;\n    }\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient_full should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = __into_field_array(quotient);\n\n    // quotient_mul_modulus_normalized can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n\n    // First, accumulate the products into quotient_mul_modulus_normalized\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus_normalized[i + j] +=\n                partial_quotient_full[i] * modulus[j] as Field;\n        }\n    }\n\n    // Then, split the accumulated values and propagate higher bits\n    let long_quotient_mul_modulus_normalized: [u128; 2 * N] =\n        __normalize_limbs(quotient_mul_modulus_normalized, 2 * N);\n    let mut quotient_mul_modulus_normalized: [u128; N] = [0; N];\n    for i in 0..N {\n        quotient_mul_modulus_normalized[i] = long_quotient_mul_modulus_normalized[i];\n    }\n\n    let mut long_remainder = __helper_sub(x, long_quotient_mul_modulus_normalized);\n    // ugly but have to remove a bunch of zeros from this\n    let mut remainder = [0; N];\n    for i in 0..N {\n        remainder[i] = long_remainder[i];\n    }\n    // barrett reduction is quirky so might need to remove a few modulus from the remainder\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n\n    (smaller_quotient, remainder)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let mut target = __helper_sub(params.modulus, one);\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target[0] & 1) == 1;\n        if (lsb_is_one) {\n            break;\n        }\n        result += 1;\n        target = __shr1(target);\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [u128; N],\n    p_minus_one_over_two: [u128; N],\n) -> (bool, [u128; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [u128; N] = __one();\n    let neg_one = __neg(params, one);\n    let found = exped == neg_one;\n    let mut result: (bool, [u128; N]) = (found, target);\n    if (!found) {\n        let _target: [u128; N] = __add(params, target, one);\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [u128; N] {\n    let mut target: [u128; N] = __one();\n    let p_minus_one_over_two = __shr1(__helper_sub(params.modulus, __one()));\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [u128; N],\n    i: u32,\n) -> u32 {\n    let one: [u128; N] = __one();\n    let is_one = t2m == one;\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n\npub(crate) unconstrained fn __increment<let N: u32>(val: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 1;\n    for i in 0..N {\n        let mut add_term = (val[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u8;\n    let remainder_shift = (120 - limb_shift) as u8;\n    let mask: u128 = (((1 as u128) << limb_shift) - 1) << remainder_shift;\n    result[0] = (input[0 + num_shifted_limbs] >> limb_shift);\n    for i in 1..(N - num_shifted_limbs) {\n        let value = input[i + num_shifted_limbs];\n        result[i] = value >> limb_shift;\n        let remainder: u128 = (value << remainder_shift) & mask;\n        result[i - 1] = result[i - 1] + remainder;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shl<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u8;\n    let remainder_shift: u8 = 120 - limb_shift as u8;\n\n    // 83\n    // limb shift = 1\n    // inside shift = 19 bits to the left\n    // meaning we have 19 carry bits and 41 remainder bits\n    let mask: u128 = (1 as u128 << 120) - 1;\n    //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n    let value = input[0];\n\n    let mut remainder = (value >> remainder_shift);\n    result[num_shifted_limbs] = (value << limb_shift) & mask;\n\n    // shift 84. num shifted = 1\n    for i in 1..((N) - num_shifted_limbs) {\n        let value = input[i];\n        let upshift = ((value << limb_shift) + remainder) & mask;\n        result[i + num_shifted_limbs] = upshift;\n        remainder = (value >> remainder_shift);\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_sub<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    for i in 0..N {\n        borrow = ((rhs[i] + borrow_in) > lhs[i]) as u128;\n        let sub = (borrow << 120) + lhs[i] as u128 - rhs[i] as u128 - borrow_in;\n        result[i] = sub;\n        borrow_in = borrow;\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_add<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr1<let N: u32>(mut input: [u128; N]) -> [u128; N] {\n    let value = input[N - 1];\n    input[N - 1] = value >> 1;\n\n    let mut remainder = (value & 1) << 119;\n\n    for i in 1..N {\n        let value = input[N - 1 - i];\n        input[N - 1 - i] = (value >> 1) + remainder;\n        remainder = (value << 119) & TWO_POW_119;\n    }\n    input\n}\n\npub(crate) unconstrained fn __get_msb<let N: u32>(val: [u128; N]) -> u32 {\n    let mut count = 0;\n    for i in 0..N {\n        let v = val[((N) - 1 - i)];\n        let v_low = v as u64 % TWO_POW_60 as u64;\n        let v_high = ((v - v_low as u128) / TWO_POW_60) as u64;\n        if (v_high > 0) {\n            count = 60 * ((2 * N) - 1 - (i * 2)) + get_msb64(v_high);\n            break;\n        }\n        if (v_low > 0) {\n            count = 60 * ((2 * N) - 1 - (i * 2 + 1)) + get_msb64(v_low);\n            break;\n        }\n    }\n    count\n}\n\npub(crate) fn __get_bit<let N: u32>(input: [u128; N], bit: u32) -> bool {\n    let segment_index: u32 = bit / 120;\n    let uint_index = bit % 120;\n    let limb: u128 = input[segment_index];\n    let value = (limb >> uint_index as u8) & 1;\n    value == 1\n}\n\npub(crate) fn __into_field_array<let N: u32>(input: [u128; N]) -> [Field; N] {\n    let mut result: [Field; N] = [0; N];\n    for i in 0..N {\n        result[i] = input[i] as Field;\n    }\n    result\n}\n","path":"/Users/ianbrighton/nargo/github.com/noir-lang/noir-bignum/v0.6.1/src/fns/unconstrained_helpers.nr"},"101":{"source":"use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __get_bit, __get_msb, __helper_add, __helper_sub, __increment,\n    __multiplicative_generator, __primitive_root_log_size, __shl, __shr,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse super::unconstrained_helpers::__shr1;\n\npub(crate) unconstrained fn __one<let N: u32>() -> [u128; N] {\n    let mut limbs: [u128; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [u128; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    limbs: [u128; N],\n) -> [u128; N] {\n    let f: [u128; N] = limbs;\n    __helper_sub(params.modulus, f)\n}\n\npub(crate) unconstrained fn __add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    // check if the result is greater than the modulus\n    if __gte(result, params.modulus) {\n        __helper_sub(result, params.modulus)\n    } else {\n        result\n    }\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    __add(params, lhs, __neg(params, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += (lhs[i] as Field * rhs[j] as Field);\n        }\n    }\n    let to_reduce: [u128; (N * 2)] = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(to_reduce, params.redc_param, MOD_BITS, params.modulus);\n    // ([0; N], [0; N])\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    let inv_divisor: [u128; N] = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut quotient: [u128; N] = [0; N];\n    let mut remainder: [u128; N] = numerator;\n\n    let b = divisor;\n    let numerator_msb = __get_msb(numerator);\n    let divisor_msb = __get_msb(divisor);\n    if divisor_msb > numerator_msb {\n        ([0; N], numerator)\n    } else {\n        let mut bit_difference = __get_msb(remainder) - __get_msb(divisor);\n        let mut accumulator: [u128; N] = __one();\n        let mut divisor = __shl(divisor, bit_difference);\n        accumulator = __shl(accumulator, bit_difference);\n\n        if (__gte(divisor, __increment(remainder))) {\n            divisor = __shr1(divisor);\n            accumulator = __shr1(accumulator);\n        }\n\n        for _ in 0..(N * 120) {\n            if (__gte(remainder, b) == false) {\n                break;\n            }\n            // we've shunted 'divisor' up to have the same bit length as our remainder.\n            // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n            if (__gte(remainder, divisor)) {\n                remainder = __helper_sub(remainder, divisor);\n                // we can use OR here instead of +, as\n                // accumulator is always a nice power of two\n                quotient = __helper_add(quotient, accumulator);\n            }\n            divisor = __shr1(divisor); // >>= 1;\n            accumulator = __shr1(accumulator); //  >>= 1;\n        }\n\n        (quotient, remainder)\n    }\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    let one = __one();\n    let exp = __helper_sub(params.modulus, __helper_add(one, one));\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n    exponent: [u128; N],\n) -> [u128; N] {\n    let x = exponent;\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [u128; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if __get_bit(x, num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn __batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n) -> [[u128; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]; M] = std::mem::zeroed();\n\n    for i in 0..M {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]; M] = [[0; N]; M];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..M {\n        let idx = M - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]],\n) -> [[u128; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]] = [];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result = result.push_front(T0);\n        } else {\n            result = result.push_front([0; N]);\n        };\n    }\n\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [u128; N],\n) -> std::option::Option<[u128; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one = __one();\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let Q = __shr(\n        __helper_sub(params.modulus, one),\n        primitive_root_log_size - 1,\n    );\n    let two = __helper_add(one, one);\n    let Q_minus_one_over_two = __shr(__helper_sub(Q, two), 2);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [u128; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut result = Option::none();\n    if (__eq(check, one)) {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __gte<let N: u32, let MOD_BITS: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> bool {\n    let mut result = false;\n    let mut early_exit = false;\n    for i in 0..(N) {\n        let idx = (N) - 1 - i;\n        if (rhs[idx] == lhs[idx]) {\n            continue;\n        }\n\n        result = rhs[idx] < lhs[idx];\n        early_exit = true;\n        break;\n    }\n    if early_exit {\n        result\n    } else {\n        lhs[0] == rhs[0]\n    }\n}\n","path":"/Users/ianbrighton/nargo/github.com/noir-lang/noir-bignum/v0.6.1/src/fns/unconstrained_ops.nr"},"103":{"source":"pub struct BigNumParams<let N: u32, let MOD_BITS: u32> {\n    pub has_multiplicative_inverse: bool,\n\n    // @brief modulus: all BigNum operations are evaluated modulo this value\n    pub modulus: [u128; N],\n\n    // @brief double_modulus: used when performing negations and subtractions\n    // @note we borrow 1 from the last limb. This is for easing up the operations that might underflow\n    pub double_modulus: [u128; N],\n\n    // @brief redc_param used for __barrett_reduction. See https://en.wikipedia.org/wiki/Barrett_reduction\n    pub redc_param: [u128; N],\n}\n\n// To be implemented by the user for any BigNum they define, or within the predefined BigNums in the `fields/` dir.\npub trait BigNumParamsGetter<let N: u32, let MOD_BITS: u32> {\n    fn get_params() -> BigNumParams<N, MOD_BITS>;\n}\n\nimpl<let N: u32, let MOD_BITS: u32> BigNumParams<N, MOD_BITS> {\n    pub fn new(\n        has_multiplicative_inverse: bool,\n        modulus: [u128; N],\n        redc_param: [u128; N],\n    ) -> Self {\n        Self {\n            has_multiplicative_inverse,\n            modulus,\n            double_modulus: get_double_modulus(modulus),\n            redc_param,\n        }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for BigNumParams<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        (self.has_multiplicative_inverse == other.has_multiplicative_inverse)\n            & (self.modulus == other.modulus)\n            & (self.double_modulus == other.double_modulus)\n            & (self.redc_param == other.redc_param)\n    }\n}\n\nfn get_double_modulus<let N: u32>(modulus: [u128; N]) -> [u128; N] {\n    let TWO_POW_120: u128 = 0x1000000000000000000000000000000;\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (modulus[i] + modulus[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n\n    result[0] += TWO_POW_120;\n    for i in 1..N - 1 {\n        result[i] += (TWO_POW_120 - 1);\n    }\n    result[N - 1] -= 1;\n    result\n}\n","path":"/Users/ianbrighton/nargo/github.com/noir-lang/noir-bignum/v0.6.1/src/params.nr"},"104":{"source":"use crate::params::BigNumParams;\nuse crate::utils::map::map;\n\nuse crate::fns::{\n    constrained_ops::{\n        add, assert_is_not_equal, cmp, conditional_select, derive_from_seed, div, eq, is_zero, mul,\n        neg, sub, udiv, udiv_mod, umod, validate_in_field, validate_in_range,\n    },\n    expressions::{__compute_quadratic_expression, evaluate_quadratic_expression},\n    serialization::{from_be_bytes, to_le_bytes},\n    unconstrained_ops::{\n        __add, __batch_invert, __batch_invert_slice, __derive_from_seed, __div, __eq, __invmod,\n        __is_zero, __mul, __neg, __pow, __sub, __tonelli_shanks_sqrt, __udiv_mod,\n    },\n};\nuse std::{cmp::Ordering, ops::Neg};\n\npub struct RuntimeBigNum<let N: u32, let MOD_BITS: u32> {\n    pub limbs: [u128; N],\n    pub params: BigNumParams<N, MOD_BITS>,\n}\n\n// All functions prefixed `__` are unconstrained!\n// They're not actually decorated as `unconstrained` because to return the `params` (as part of Self) from an `unconstrained` fn would cause range constraints. Instead, each `__` fn wraps a call to an unconstrained fn, so that the already-range-constrained `params` can be inserted into Self after the unconstrained call.\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNum<N, MOD_BITS> {\n\n    pub fn zero(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let limbs: [u128; N] = [0; N];\n        Self { limbs, params }\n    }\n\n    pub fn one(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let mut result = RuntimeBigNum::zero(params);\n        result.limbs[0] = 1;\n        result\n    }\n\n    pub fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = __derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    pub fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [u128]) -> Self {\n        Self { limbs: limbs.as_array(), params }\n    }\n\n    pub fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [u128; N]) -> Self {\n        Self { limbs, params }\n    }\n\n    pub fn from_be_bytes<let NBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        x: [u8; NBytes],\n    ) -> Self {\n        Self { limbs: from_be_bytes::<_, MOD_BITS, _>(x), params }\n    }\n\n    pub fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes] {\n        to_le_bytes::<_, MOD_BITS, _>(self.limbs)\n    }\n\n    pub fn modulus(self) -> Self {\n        let params = self.params;\n        Self { limbs: params.modulus, params }\n    }\n\n    pub fn modulus_bits() -> u32 {\n        MOD_BITS\n    }\n\n    pub fn num_limbs() -> u32 {\n        N\n    }\n\n    // fn get(self) -> [Field] {\n    //     self.get_limbs()\n    // }\n\n    pub fn get_limbs(self) -> [u128; N] {\n        self.limbs\n    }\n\n    pub fn get_limb(self, idx: u32) -> u128 {\n        self.limbs[idx]\n    }\n\n    pub fn set_limb(&mut self, idx: u32, value: u128) {\n        self.limbs[idx] = value;\n    }\n\n    pub unconstrained fn __eq(self, other: Self) -> bool {\n        assert(self.params == other.params);\n        __eq(self.limbs, other.limbs)\n    }\n\n    pub unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __neg(self) -> Self {\n        let params = self.params;\n        let limbs = unsafe { __neg(params, self.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __add(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __sub(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __mul::<_, MOD_BITS>(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        let limbs = unsafe { __div::<_, MOD_BITS>(params, self.limbs, divisor.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = unsafe { __udiv_mod(self.limbs, divisor.limbs) };\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __invmod(self) -> Self {\n        let params = self.params;\n        assert(params.has_multiplicative_inverse);\n        let limbs = unsafe { __invmod::<_, MOD_BITS>(params, self.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __pow(self, exponent: Self) -> Self {\n        let params = self.params;\n        assert(params == exponent.params);\n        let limbs = unsafe { __pow::<_, MOD_BITS>(params, self.limbs, exponent.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs =\n            unsafe { __batch_invert::<_, MOD_BITS, _>(params, x.map(|bn| Self::get_limbs(bn))) };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // Note: can't return a slice from this unconstrained to a constrained function.\n    pub unconstrained fn __batch_invert_slice<let M: u32>(x: [Self]) -> [Self] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs = {\n            let inv_slice =\n                __batch_invert_slice::<_, MOD_BITS>(params, x.map(|bn| Self::get_limbs(bn)));\n            inv_slice.as_array()\n        };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self> {\n        let params = self.params;\n        let maybe_limbs = unsafe { __tonelli_shanks_sqrt(params, self.limbs) };\n        maybe_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self) {\n        let (q_limbs, r_limbs) = unsafe {\n            __compute_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n                params,\n                map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                lhs_flags,\n                map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                rhs_flags,\n                map(linear_terms, |bn| Self::get_limbs(bn)),\n                linear_flags,\n            )\n        };\n        (Self { limbs: q_limbs, params }, Self { limbs: r_limbs, params })\n    }\n\n    pub fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) {\n        evaluate_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            rhs_flags,\n            map(linear_terms, |bn| Self::get_limbs(bn)),\n            linear_flags,\n        )\n    }\n\n    pub fn validate_in_field(self: Self) {\n        let params = self.params;\n        validate_in_field::<_, MOD_BITS>(params, self.limbs);\n    }\n\n    pub fn validate_in_range(self) {\n        validate_in_range::<_, _, MOD_BITS>(self.limbs);\n    }\n\n    pub fn assert_is_not_equal(self, other: Self) {\n        let params = self.params;\n        assert(params == other.params);\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    pub fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = udiv_mod::<_, MOD_BITS>(params, self.limbs, divisor.limbs);\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    pub fn udiv(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: udiv::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    pub fn umod(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: umod::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    pub fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self {\n        let params = lhs.params;\n        assert(params == rhs.params);\n        Self { limbs: conditional_select(lhs.limbs, rhs.limbs, predicate), params }\n    }\n\n    pub fn is_zero(self) -> bool {\n        is_zero::<N, MOD_BITS>(self.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Add for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: add::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Sub for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: sub::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Mul for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: mul::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Div for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: div::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> Neg for RuntimeBigNum<N, MOD_BITS> {\n    fn neg(self) -> Self {\n        let params = self.params;\n        Self { limbs: neg::<_, MOD_BITS>(params, self.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for RuntimeBigNum<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        let params = self.params;\n        assert(params == other.params);\n        eq::<_, MOD_BITS>(params, self.limbs, other.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> std::cmp::Ord for RuntimeBigNum<N, MOD_BITS> {\n    fn cmp(self, other: Self) -> Ordering {\n        assert(self.params == other.params);\n        cmp::<_, MOD_BITS>(self.limbs, other.limbs)\n    }\n}\n","path":"/Users/ianbrighton/nargo/github.com/noir-lang/noir-bignum/v0.6.1/src/runtime_bignum.nr"},"111":{"source":"use crate::constants::TWO_POW_120;\n\nunconstrained fn split_120_bits(mut x: Field) -> (u128, u128) {\n    // Here we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low = (x as u128) % TWO_POW_120;\n    let high = ((x - low as Field) / TWO_POW_120 as Field) as u128;\n    (low, high)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [u128; N] {\n    let mut normalized: [u128; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(next);\n        normalized[i] = lo as u128;\n        next = input[i + 1] + hi as Field;\n    }\n    {\n        let (lo, hi) = split_120_bits(next);\n        normalized[range - 1] = lo as u128;\n        assert(hi == 0);\n    }\n    normalized\n}\n","path":"/Users/ianbrighton/nargo/github.com/noir-lang/noir-bignum/v0.6.1/src/utils/split_bits.nr"},"113":{"source":"use dep::bignum::{params::BigNumParams, RuntimeBigNum};\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature to the original message hash\n * @details Taken from https://github.com/richardliang/noir-rsa\n **/\nfn compare_signature_sha256<let N: u32>(padded_sha256_hash: [u8; N], msg_hash: [u8; 32]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    // NOTE: Assume MAX_BYTES < 2^32 bit number. MAX_BYTES of 259 > 2^8 bits so need to cast it to u32\n    for i in 0..32 {\n        // Padded hash is reversed\n        assert(padded_sha256_hash[31 - i] == msg_hash[i]);\n    }\n\n    let hash_prefix: [u8; 19] =\n        [32, 4, 0, 5, 1, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 49, 48];\n\n    for i in 32..51 {\n        assert(hash_prefix[i - 32] == padded_sha256_hash[i]);\n    }\n\n    assert(padded_sha256_hash[51] == 0);\n\n    // Sub 32 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 54;\n    for i in 52..N {\n        if i < 52 + ps_len {\n            // PS padding which depends on RSA modulus / sig length. 1024 bits = 128 bytes = 128 - 54 = 74 bytes of 0xFF padding\n            assert(padded_sha256_hash[i] == 255);\n        } else if i == 52 + ps_len {\n            // Pad 0x01\n            assert(padded_sha256_hash[i] == 1);\n        } else if i == 53 + ps_len {\n            // 0x00\n            assert(padded_sha256_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha256_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Verify an RSA signature generated via the pkcs1v15 signature scheme.\n * @note The `exponent` can be either 65537 or 3 (i.e. the most common values in use for RSA)\n * Rough cost: 2,048 bit RSA: 26,888 gates per verification\n *             1,024 bit RSA: 11,983 gates per verification\n * A circuit that verifies 1 signature (and does nothing else) will cost ~32k due to initialization costs of lookup tables\n **/\npub fn verify_sha256_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    assert((exponent == 3) | (exponent == 65537), \"Exponent must be 65537 or 3\");\n    let mut exponentiated = sig * sig; // sig^2\n    if exponent == 65537 {\n        // e = 65537 = 1 0000 0000 0000 0001\n        exponentiated = exponentiated * exponentiated; // sig^4\n        exponentiated = exponentiated * exponentiated; // sig^8\n        exponentiated = exponentiated * exponentiated; // sig^16\n        exponentiated = exponentiated * exponentiated; // sig^32\n        exponentiated = exponentiated * exponentiated; // sig^64\n        exponentiated = exponentiated * exponentiated; // sig^128\n        exponentiated = exponentiated * exponentiated; // sig^256\n        exponentiated = exponentiated * exponentiated; // sig^512\n        exponentiated = exponentiated * exponentiated; // sig^1024\n        exponentiated = exponentiated * exponentiated; // sig^2048\n        exponentiated = exponentiated * exponentiated; // sig^4096\n        exponentiated = exponentiated * exponentiated; // sig^8192\n        exponentiated = exponentiated * exponentiated; // sig^16384\n        exponentiated = exponentiated * exponentiated; // sig^32768\n        exponentiated = exponentiated * exponentiated; // sig^65536\n    }\n    // otherwise, e = 3 = 11\n    exponentiated = exponentiated * sig; // either sig^2 * sig = sig^3 or sig^65536 * sig = sig^65537\n    let mut padded_sha256_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha256(padded_sha256_hash_bytes, msg_hash)\n}\n\npub fn verify_sha256_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    key_size: u32,\n) -> bool {\n    // Exponentiate the signature assuming e = 65537\n    let mut exponentiated = sig * sig;\n    for _ in 0..15 {\n        exponentiated = exponentiated * exponentiated;\n    }\n    exponentiated = exponentiated * sig;\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; ModBits / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = key_size - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (key_size + 7) / 8;\n    let h_len = 32;\n    let s_len = 32;\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L242\n    let offset = key_len - em_len;\n    // As the hash is 32 bytes and we also remove the 0xBC at the end, we have up to NumBytes - 33 bytes left for DB\n    // For example, for 2048 bit RSA (i.e. 256 bytes), we have 256 - 33 = 223 bytes left for DB\n    // and for 1024 bit RSA (i.e. 128 bytes), we have 128 - 33 = 95 bytes left for DB\n    let masked_db: [u8; (ModBits / 8) - 33] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L205\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1\n    let db_mask: [u8; (ModBits / 8) - 33] = mgf1_sha256(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits / 8) - 33];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 32] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 72]; // 8 + h_len + s_len\n    for i in 8..40 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 40..72 {\n        m_prime[i] = salt[i - 40];\n    }\n\n    // Compute H'\n    let h_prime = dep::std::hash::sha256(m_prime);\n\n    // Compare H and H'\n    h == h_prime\n}\n\nfn reverse_array<let N: u32>(array: [u8; N]) -> [u8; N] {\n    let mut reversed = [0 as u8; N];\n    for i in 0..N {\n        reversed[i] = array[N - i - 1];\n    }\n    reversed\n}\n\nfn get_array_slice<let N: u32, let M: u32>(array: [u8; N], start: u32, end: u32) -> [u8; M] {\n    assert(end - start <= M);\n    let mut slice = [0 as u8; M];\n    for i in 0..M {\n        if i < end - start {\n            slice[i] = array[start + i];\n        }\n    }\n    slice\n}\n\nfn pow(base: u32, exp: u32) -> u32 {\n    let mut result = 1;\n    for _ in 0..exp {\n        result *= base;\n    }\n    result\n}\n\nglobal HASH_LEN: u32 = 32;\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA256 as the hash function\n **/\nfn mgf1_sha256<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * HASH_LEN\n    std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * HASH_LEN as Field + 1);\n\n    // HASH_LEN bytes are added at each iteration and there is at least 1 iteration\n    // so if HASH_LEN is not enough to fill MASK_LEN bytes in one iteration,\n    // another one is required and so on.\n    let iterations = (MASK_LEN / HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; HASH_LEN] = [0; HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        // Hash the block\n        // First SEED_LEN bytes are the seed, next 4 bytes are the counter\n        hashed = dep::std::hash::sha256_var(block, SEED_LEN as u64 + 4);\n\n        // Copy hashed output to mask\n        for j in 0..HASH_LEN {\n            if i * HASH_LEN + j < MASK_LEN {\n                mask[i * HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n#[test]\nfn test_verify_sha256_pkcs1v15_1024() {\n    // Output of `cargo run -- --msg \"hello world! test#123\" --bits 1024` in the `signature_gen` directory\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"hello world! test#123\".as_bytes());\n    assert(\n        sha256_hash\n            == [\n                220, 155, 229, 143, 122, 133, 55, 215, 75, 44, 132, 111, 57, 33, 248, 84, 213, 170,\n                193, 96, 253, 57, 124, 13, 251, 42, 92, 147, 105, 172, 233, 85,\n            ],\n    );\n\n    let params: BigNumParams<9, 1024> = BigNumParams::new(\n        false,\n        [\n            0xab238ad9cb37979a43aefbf10be8fb,\n            0x31347febe45fe8c2dac1dd30900704,\n            0xa5a9a6b9cd0cc2b9d13bbd4e068263,\n            0x5eac6390f7873fe97ff9bb14a173ea,\n            0xbc41f700c91fd733a2c63177bbdbd4,\n            0x41442bd58769a3595b659a2ec9c6be,\n            0x4ddc91395f330382aa2e2d3fbe147,\n            0x3d008ff255a0bc71c7887f5728ba1,\n            0xb640c3a8f511c64e,\n        ],\n        [\n            0x5d53d2634c6a0918266043968ce263,\n            0x5dd4be3dce0323a492ee9340aec4db,\n            0xf82d0e2e5c8319f01a460c72c01854,\n            0x236e6fc6e62e8a1d522acda5fb3892,\n            0xdaf755619d66e580901aa224d03174,\n            0x8366291616480e7e1f202dbcedda87,\n            0x40ba1202537d1e94561ccc05265586,\n            0x69b993d857ba89ea5de9822aeb4b93,\n            0x167968c0000761a273,\n        ],\n    );\n\n    let signature: RuntimeBigNum<9, 1024> = RuntimeBigNum {\n        params,\n        limbs: [\n            0xc3850e84ea02da3f028ff422f4d6a9,\n            0x9761f0bd9021f76d45c60df0670a19,\n            0xc1ede421a43607ab623ed4d5a17fc8,\n            0x86197b4315206f4d53200b42555831,\n            0xe95783b69db28c26a83706f39d04cd,\n            0x18b178dc1a9ec76fb22b57e4dfa703,\n            0xdd0e19cd5a09ab48e7af4d0e3470e3,\n            0x10004dfab1cf91304e80e6baa4dfc7,\n            0x241c3fd77b90adef,\n        ],\n    };\n\n    assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n}\n\n#[test]\nfn test_verify_sha256_pkcs1v15_2048() {\n    // Output of `cargo run -- --msg \"Hello World! This is Noir-RSA\"` in the `signature_gen` directory\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"Hello World! This is Noir-RSA\".as_bytes());\n    assert(\n        sha256_hash\n            == [\n                91, 207, 46, 60, 22, 153, 217, 144, 2, 127, 224, 143, 181, 45, 32, 120, 122, 131,\n                166, 79, 166, 183, 43, 158, 116, 105, 73, 207, 196, 77, 33, 5,\n            ],\n    );\n\n    let params: BigNumParams<18, 2048> = BigNumParams::new(\n        false,\n        [\n            0x8d5e7d9daedd6cfd1c9bdf0227e05b,\n            0xbfb937fc4d3cf02cc0af780f3cab44,\n            0xd20637ef7adcf5d238ee87bccc9bca,\n            0xb9db4f2663108e2f8b673f7612ae8b,\n            0x85f894ef669b36bfd3d86b0a28873,\n            0xdcc70e1884e38b8229cce3b884121d,\n            0x35488d1138e0b03e1676f7f5d8a5b3,\n            0xe1a97820e7dcbb4eab35c9b71bb273,\n            0x97d19eb3c63249ddbfcff915863f54,\n            0x3a78c7af6da0f6af0d67b1ca4b6065,\n            0xd7a3c433c020f624821e5e678c7d69,\n            0x52d5b53240feae82ffea3d2a3d9b09,\n            0xb8aad5e19e2163f68997c6fdd71906,\n            0x5db432d06e8b0bf59511100c7894e2,\n            0xadc0bbc4c54da10d1cc88438ea3127,\n            0xece1cf6a1501109cd2734d5893c8d9,\n            0x7196b90acdf06c31b1288064fd0c27,\n            0xc8,\n        ],\n        [\n            0x1b1deccf4dbde852c34a5d6908a0f,\n            0xbc9e5bdab22f023fbcca58692bccf5,\n            0x1f65439685623e45396ff55751c3bf,\n            0x2b6ad2c5f8e3aac15d0ccbab816bfa,\n            0x5ca2e8e3048243c16c708a8030ab0d,\n            0x30079bfeb1fa51e5501581173ca19c,\n            0xff8d5f6bea485fdcc2716327f69ab4,\n            0x36b599d81589416b5b5f037986b999,\n            0x75612e34a4ff29f0a19a7823512f58,\n            0x288b6897929b54c3b26a5faa07c00f,\n            0x4b5675fa13ab7444f1f047d3eb1bbe,\n            0x6ba0ac610ef9f267ab30fe25bb1c84,\n            0xa386b48ee03168d5cea3ecb9dc901f,\n            0xacf1a01f7dba44e050c976142fb1f6,\n            0x97a63b5cb7efc60d3502946aec63cf,\n            0x12cc1d5cab10a1e9e2398d29b9e3ef,\n            0x4635cf25c66e76bba8034df46204fb,\n            0x146f,\n        ],\n    );\n\n    let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n        params,\n        limbs: [\n            0xad29e07d16a278de49a371b9760a27,\n            0x86311920cc0e17a3c20cdff4c56dbb,\n            0x863556c6c5247dd83668dd825716ae,\n            0xc247c960945f4485b46c33b87425ca,\n            0x7326463c5c4cd5b08e21b938d9ed9a,\n            0x4f89fe0c82da08a0259eddb34d0da1,\n            0x43a74e76d4e1bd2666f1591889af0d,\n            0x240f7b80f0ff29f4253ee3019f832d,\n            0xc6edd131fbaaf725fd423dac52b362,\n            0x85f9732679242163e8afff44f6104d,\n            0xd3c3bbcb1757013fd6fb80f31dd9a6,\n            0x9008633f15df440e6df6d21ee585a2,\n            0x324df3425ed256e283be5b6b761741,\n            0xc60c1302929bd0e07caa4aeff4e8fd,\n            0x600d804ff13ba8d0e1bc9508714212,\n            0x50f7e75e5751d7edd61167027926be,\n            0x0db41d39442023e1420a8a84fe81d9,\n            0xab,\n        ],\n    };\n    assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n}\n\n#[test]\nfn test_verify_sha256_pkcs1v15_2048_exponent_3() {\n    // Output of `cargo run -- --msg \"hello world\" -e 3` in the `signature_gen` directory\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"hello world\".as_bytes());\n    assert(\n        sha256_hash\n            == [\n                185, 77, 39, 185, 147, 77, 62, 8, 165, 46, 82, 215, 218, 125, 171, 250, 196, 132,\n                239, 227, 122, 83, 128, 238, 144, 136, 247, 172, 226, 239, 205, 233,\n            ],\n    );\n\n    let params: BigNumParams<18, 2048> = BigNumParams::new(\n        false,\n        [\n            0xe40ee47801326543c8e84b85d567c1,\n            0x5b54ea87f0ce29de1995697b0696fd,\n            0x457078f8fdce68b437cac0970b2452,\n            0x473ec776fee3731b6ab06e35875ddc,\n            0x62dedd594e5f12c80c3ccb5791a6cd,\n            0xecb934b9d8272c5e3a418145345499,\n            0xd1af643b3d785470ed0c6cd633f706,\n            0xb58a57b9e96eccbdfc7c17f0333d4,\n            0x2ebd34b5039fc596504927c282c60d,\n            0x3a44928a74f25fc1043bb37ce4dfa8,\n            0x91448459f9617fac33a2816162ac9e,\n            0x70cb910d9f3e1a78864640ec6c8240,\n            0x9aed33f6b31f1c9de67248a98c180,\n            0x7f1416e032c79488c94b311e87bd9c,\n            0x7191b4ebb1b3fffa949fa48ed01e5,\n            0x350a75cbaeca6bfdd71ca83cdbcae9,\n            0xfb1d274fa207457c6814d42c09f9cf,\n            0xd4,\n        ],\n        [\n            0x803bf4d38110a7d37fdd05f590dee9,\n            0xa68d317c933f37cab5ab4e7c00a3b9,\n            0x476a05a536bf5f2aa1b8850146cba7,\n            0xca297ea8b5528d91d4836ff27c30ab,\n            0x75cf2eaab76eefa12bbd570f1aea9f,\n            0x8f6a8ab877d9c5bcd98c37bdc5c2d3,\n            0xd497db1f6ebe83decacaa647fabea6,\n            0x686b27ca330e25e7a7cf197f6433ef,\n            0xfde04d2225c8308b07580af0058a0f,\n            0xa29fb69777c0e916976243b2b09855,\n            0xf983592285852e7e1c2cb3ae968323,\n            0x673608017f9f5acf67a01b73728d70,\n            0xeeff82521c0bc432a05f4b7444fac0,\n            0x85a89c4d229f60aaa3aa7ac7dac1e2,\n            0xcfecff93bc9fbfe0d6dff6091f2db8,\n            0xf20f047dcb224b4447bd098c07f8c2,\n            0x554bb53cadeb3eaab911a189f90227,\n            0x133b,\n        ],\n    );\n\n    let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n        params,\n        limbs: [\n            0xa250eff812c63eaaeaa3f04641c05f,\n            0xecc09613cb8b289c1f37c8f92e6a05,\n            0x2c0a0510058360c07af65d46f594fd,\n            0x943d67513363d3de430c94a1dafe7c,\n            0x511ec8e9b10bc6c6ff0d6c232ccf92,\n            0x50ffd07b3c093b3f5fc027de847731,\n            0xc268e1489449943fdafdf89ff168c3,\n            0x0b8b7f9f49b492f78fda58d252f23a,\n            0x491c6c4ef836a6a8730b7bf81e865e,\n            0x8746c75fb079d014e419543f56d7f0,\n            0x65804c417d6168a8bc0025d255cebf,\n            0xf695e91b77890b8e3fd775fa56e627,\n            0x5e90001c0218550f4083ae28025a2f,\n            0x526bd4eff34f25f62a698f0470e0a6,\n            0x7f224306a7d9daf536b1559434c6c6,\n            0x88809f16fe1fcea3c87511d9319735,\n            0x7694685fee0bfab4a9196b92ec6f2e,\n            0xa7,\n        ],\n    };\n\n    assert(verify_sha256_pkcs1v15(sha256_hash, signature, 3));\n}\n\n#[test]\nfn test_mgf1_sha256() {\n    let seed: [u8; 32] = dep::std::hash::sha256(\"Hello World! This is Noir-RSA\".as_bytes());\n    let expected_mask: [u8; 32] = [\n        106, 93, 232, 46, 236, 203, 51, 228, 103, 104, 145, 29, 197, 74, 26, 194, 135, 200, 40, 232,\n        179, 172, 220, 135, 51, 185, 209, 35, 194, 131, 176, 190,\n    ];\n    let mask: [u8; 32] = mgf1_sha256(seed);\n    assert(mask == expected_mask);\n}\n\n#[test]\nfn test_verify_sha256_pss_2048() {\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"Hello World! This is Noir-RSA\".as_bytes());\n\n    let params: BigNumParams<18, 2048> = BigNumParams::new(\n        false,\n        [\n            0x45648f4ade2ac1f40c18b44a2951ad,\n            0xd558cced315cbced65532e416ab0ea,\n            0x67c3818b41ed79f0e9e06b10b31a39,\n            0x9bb9db99001fe165b2a18bfb8ff423,\n            0xc792c2037f2abe206bdc987898a73b,\n            0x6630acf8743e8ffca5199b195d2e32,\n            0xbffc9f0464184da3de5f0efa5a705b,\n            0xe14bd49bd3ec93d8f3e84f47a32e6d,\n            0x2d6abfec39882cd67f7804b9ff278e,\n            0x1140883fa39129d297ebee534cdf58,\n            0x96bc387e08849589aa1dda5d381cd2,\n            0x31c60ecdf4d3c1119814b724779a9e,\n            0x1a4882267e3e2e6074b40448d62087,\n            0x9e015854d57eae42e5b515d357a755,\n            0xb593f8dfc8434f32d7d30277b1abc,\n            0x4e7184b54966a30552fc92df470aa,\n            0xa8a3c9172762978b03464671f8288e,\n            0xba,\n        ],\n        [\n            0x1c63831dbaa98693ab59ca2ae5a88,\n            0x3e67cf06ca2556701f3aa8d158552,\n            0x7c63171078a831165ed8b2dd116675,\n            0x9e1f1bca55d0e220e58ddbbb387972,\n            0xd7c72f20722cc7af897d5819424801,\n            0xf0434a631cffe4c4d56874bff93661,\n            0x8767e83f45cfff15cca95d5dc6f48c,\n            0xf210d697748e9ad45c0f7c3ed3bda8,\n            0xc960d59cb9dd48d50e12c2ef04dda2,\n            0xbf07cf1ecc532686848dca09d061c2,\n            0xc491a60be200f9574ad6aa31977a4f,\n            0x67681170f25ab2aff941b18e21e1bd,\n            0xc485fc6deda1ba84f2bfcfbea2c044,\n            0x776bc3eac3728ec7f85ca2496ee8e4,\n            0x4d82eeb8ecdc1ec53280fce96c05e,\n            0x514088d39ff1cae50d2f67db91458f,\n            0x9c1553de9eef61a83b288c4d11610e,\n            0x15f1,\n        ],\n    );\n\n    let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n        params,\n        limbs: [\n            0xcce57aaed9eed21edef9d96d9ebdf8,\n            0x181f152657736ea458462ff45b1d81,\n            0x9df8c00fefe67c3a727c1f84641d2a,\n            0xe3bb299609d4f4bfe7e979123f6962,\n            0x6cf987c686983f184262419dc8d64b,\n            0xedc086f713d60c9d661a4e7fdae380,\n            0xb95ada34d5b9217d9eaa89d1d7a3d1,\n            0xec275d1d4e3e74296eab26318df81f,\n            0x3c943e2d3e12f1394952de70d92ac9,\n            0x4a4e8a625138a533b9b71cbb03c991,\n            0xa5379dfc363e79c5a55ad71a01948e,\n            0x9340e047e0d4be67ac7f1517fe2673,\n            0xdf2606ac8cbbcad391c5e925bf5082,\n            0x249690032f10b7986e7edbb8ec0d6a,\n            0x8c07da4fbed69ab71f127fb5edf73c,\n            0x64aefd403b6a4353ebdc9b7fce82bc,\n            0x5ecc107633bc4cc1a3adb545b474de,\n            0x7b,\n        ],\n    };\n\n    assert(verify_sha256_pss(sha256_hash, signature, 2048));\n}\n\n#[test]\nfn test_verify_sha256_pss_4096() {\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"Hello World! This is Noir-RSA\".as_bytes());\n    let params: BigNumParams<35, 4096> = BigNumParams::new(\n        false,\n        [\n            0xa6222b52f49e7258fe4fee04ea2d9,\n            0x2fd64c9fce4dba1e003e9b0947ee34,\n            0xf46a24f43be90f258013ba55794c6a,\n            0xda8100ed967a7577f4144295e37b68,\n            0x8545db58ed5cb1a78661a725c2e2df,\n            0xfc1673fba9882dc0c1bf1ebd95e9a7,\n            0xf8863f5481969b504d93ec7b3634f,\n            0xafedf06a9d7583f1c06b2ee8a1f2b8,\n            0x375c3f57b70cb7fc6b934445a97ebe,\n            0xd89ad291b95a70bf4922b45d2efff8,\n            0x2bf000f6408944083d93e45030e827,\n            0xf55cb42313719c7a2bfa07b3eb1ed4,\n            0x6d8656a0f3b41fa1a717140dc5ce90,\n            0x404b10d983681bd3f9ed1534d5bfa2,\n            0xced48aead2b9ba16f08a0fb968a96c,\n            0x43acf088910c3322f7da5c2d0a2211,\n            0x58b7e2d7b7f268eb990fc464defe90,\n            0x2be3be3a4fedf432a98dda3c220958,\n            0xf9156a2bafb69ef294360c25d22759,\n            0x1b7e6763845875a1886345b4ee8940,\n            0xa40ae130e9762120841e1930873975,\n            0x2d883272a543cf8fd0cdfbecc94367,\n            0x715a88142fec78eb472f6684cd942d,\n            0xdd302fea25298915e2db875f6ab621,\n            0x6612ced822df9c00c368466391fe23,\n            0x48acb5eea186585b9c24443397b8fb,\n            0x53fc8b5e2bedc30b81f632371f1e8a,\n            0x7ef026faeb670fc44abfeee192bec6,\n            0xb07bb4bfb19773a319052ffac029a9,\n            0x81c21e9e538893cb04debde34bc02e,\n            0x823427edc35eaf0a2f5d493318db74,\n            0xbad02f47a1ff078d0103affc3792b1,\n            0xe297eab3b3edafcf99c2ba52cb8424,\n            0x3e7e575d40629a07980fa71996e807,\n            0xc27a,\n        ],\n        [\n            0x54aba16603d87dec091aa1821ce3b0,\n            0x8f6a9c560fe4f4d5fb83999853bd1c,\n            0x4d9b41fcc316ae6b1a9bb7eefa7713,\n            0x623fcac3bfa0aa5f932acc0f0f28c9,\n            0xb29eca15e9ba6d9bbcd2ac543f9558,\n            0x43689b8fe8bbb48269c2fb3b03a624,\n            0xc6f8b1cbefb4cb7d2eec1bc951808b,\n            0x4074a7837f67403f497133fee0e29,\n            0x536ba97fd34f92aae1e0354bc17db0,\n            0x784c203e438e43ddddae491fd0c0e9,\n            0xf41ae3f5f5060d212bcc7c4ee71d2,\n            0xe539fd3b39a98377199ae15d165ea,\n            0xd13be03a50e9694c4c84e2541303ed,\n            0x38136b8771f62c9778e1f812ceadec,\n            0x23bea00ab5c2efafde2c8ea46673a8,\n            0xa4d3523ba9389da81c46adde61fece,\n            0xadb3053369bb6e7233eea01174caa2,\n            0x68995fa9f373e420a9f6e6fa2329e7,\n            0x38f83f074d3ee3674e7336349a0d4e,\n            0xd9ecb79c431b08a695e4808a636a48,\n            0x3498c268b8bb4936c9e8f9fa73da27,\n            0x123ed10b1358dde62125f1191fc922,\n            0xa5a412e4c3c73dbb5cba119c48af2d,\n            0xbee3217219d507e4a6ff74b9b9eee5,\n            0x2ee5efcaee7ca45ffcd85f10eeb21b,\n            0xb977bc65277e5723737f52905837bc,\n            0xd1fd3aa6e7717bceccf73b04c8bf2d,\n            0x7964355f3acd61d2408ce20a964740,\n            0xfc2e76f487e6ca0e6bcadbf9d3801d,\n            0xfb0ea20336cf95062efb880d82cab5,\n            0x6884d9ca882e37df90f8f5c603b7b1,\n            0x9be945fc633fcc0dd2b84ec1debef5,\n            0x8d834cbc2c9a3aa4a85a3994bc569d,\n            0x7055060035c122b095b75e6de37d48,\n            0x150fc2,\n        ],\n    );\n    let signature: RuntimeBigNum<35, 4096> = RuntimeBigNum {\n        params,\n        limbs: [\n            0xdeb402a595b32a248fd427ed84c743,\n            0x75f1b3656f2eb61c3e4164375052cf,\n            0x33aa80998875b8b48263611706607b,\n            0xd9c80be79f586e80ac3af1a8d5ea53,\n            0xf0b116fd85546f206ae49d041d0223,\n            0x406a397f56e62863aa7b6ed1429dec,\n            0xd7e0bbd7ac00a419f3fef0098e904f,\n            0x303665df221e3691c84c6502d1b807,\n            0xb2ce0e36df94a88f8120b53a0bcb84,\n            0xe8e55991ffdb5b731b77cb249991d1,\n            0xbaa946c3acb9696a4d416d86291fd2,\n            0x7746a7486603b1cfb5dc5f800ee409,\n            0x567d9470319309142967b699404091,\n            0x5ee6fbb50c8637805ec6c7780a9e0a,\n            0x32bf8a51bc178cdb664ca911c857ea,\n            0xe928146ddcc0865c10215611955243,\n            0x5d12083acd2e3a1b7f7313dea0b894,\n            0x8620f5ba7615db0a3285c735813a73,\n            0x7b84f0e392902e84792c4879f48fbc,\n            0x1437df81c544ea4d7fdb020bfb7fcb,\n            0x09fb8b36d3a58a6a5fff27c1664d97,\n            0xef70898862d34d8f2d7c1bb1fb8103,\n            0xd24f625196ae71e3064596a7dd80f3,\n            0xeb646b3e5958fc213a0f711a5c68c4,\n            0x7f57a200d1894a07a33610c56a543d,\n            0xa54baf3fadfe09f896d2f2c88df7e7,\n            0xb605122c80e189236329bbf9ad6c9f,\n            0xa6ac0b396215d0f50b3705cd08788a,\n            0xdad6946e3c27a25ab484a0ed338788,\n            0x874dfd4c3723c395217a881b93283a,\n            0xf5ac1d98a50f59a40db4e2d4864a07,\n            0x9d6ed5b0d10028a291588a3359cd32,\n            0x7d8b67a1bad38a5ec750dc27bc8ae0,\n            0xa2ddd25f61adf97f5e2e8a0ef99ba8,\n            0x2244,\n        ],\n    };\n    assert(verify_sha256_pss(sha256_hash, signature, 4096));\n}\n\n// doesnt work yet need better method\n// #[test]\nfn test_verify_sha256_pss_1964() {\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"Hello World! This is Noir-RSA\".as_bytes());\n    let params: BigNumParams<17, 1964> = BigNumParams::new(\n        false,\n        [\n            0xe62ce4613d178a8af9154a28c804c9,\n            0xe9c80bb90ee949aa26d5554f5b7323,\n            0xa823c32e66dce57c7617704f092c82,\n            0x8b7eee92772e414a23ee9dd5ef843a,\n            0x6590039cb62daeea7a96faf674175c,\n            0x2905f4400973a1442181701f12f30d,\n            0xc5f0a37929848a5fbe070ddc915dee,\n            0x2ada1490d935ef7700c43dc2565539,\n            0xa99acb3b526abb963d71e527c17e2e,\n            0xf9d79341476659c231dc93313fb440,\n            0x168d8abd0528fa146b6401034358f2,\n            0x6d7386e7d66bec5392a463d34f7b5d,\n            0xeb245f85612f76849ce32cd5f9011e,\n            0x2d171c40f36f34eeb17b4643c7f9e2,\n            0xd582273cf4c5fb0c195ccac1526478,\n            0x1df64d0a6c95698d34c1b16640ad92,\n            0xdd8e29ecdc0,\n        ],\n        [\n            0x7893f159b37d9b4d46e77e420d3315,\n            0x97913c7ea0db74a13b793686c0fa,\n            0x3eddab2786c599e1fcd99b06a1b151,\n            0x6f922b72a2386f483d35d5017ef102,\n            0xcf9ede21d4ca70a045ccdac95c1e9,\n            0xbe7c0cc79955f74eafb82000838e19,\n            0x26bd0fc82288bde663f5dff239b55b,\n            0x95f857821550531b848b454b4f7dc7,\n            0xef08d9d594fbf1547ac00a03323aa7,\n            0x3bb9f9263bfe85814477c58de4934d,\n            0x214887fd218e3573f1aae50917a816,\n            0xe6f1abc97678adf59b2008645d8802,\n            0x28dd35618649eef12941db95081242,\n            0xc13764316f70444e7120b6ae5088f5,\n            0xefb1aba9512f1b2c88db34a4938796,\n            0x6aed9a143fb37749eca936a60ae25c,\n            0x127ccb9568ee6,\n        ],\n    );\n\n    let signature: RuntimeBigNum<17, 1964> = RuntimeBigNum {\n        params,\n        limbs: [\n            0x37c3a3f915fb9e787412d457ec4a63,\n            0xd60918c40b6c50bcc8afa8d1ea754f,\n            0x98eec8d63deeb22eca4f9d15b7e935,\n            0xc841db8c9930934dcc8171a5fee4b4,\n            0x3341bdb96ed1d734959e257dbc85ca,\n            0x32701c7557ca04c15cd9e18f45d37b,\n            0xefd3dae979f5a920654dc7a3ea2277,\n            0x1d6724ec09b112e8776c115874a53f,\n            0xf403d3593f85b9ab421fa26bf99298,\n            0x04e85e3628f4c3fc254a92c56ba0b8,\n            0x975bb82f1fe3c3d1656e098682f69f,\n            0x0ad72d532c8e6e17398d918c360973,\n            0xc4ba256370766c633e77d4102a8919,\n            0xc4d3bb32bc889aca394bef272d3f71,\n            0x5d56778a3d1ad3117471d4060761b0,\n            0x5fd5d71fec72f615614d6347935f35,\n            0x09ab8ab67e43,\n        ],\n    };\n    assert(verify_sha256_pss(sha256_hash, signature, 4096));\n\n}\n\n#[test]\nfn test_verify_sha256_pss_jwt() {\n    let hash: [u8; 32] = [\n        190, 196, 184, 50, 102, 89, 57, 43, 211, 245, 140, 168, 170, 163, 80, 128, 25, 139, 25, 68,\n        239, 215, 154, 164, 148, 234, 47, 212, 6, 140, 157, 110,\n    ];\n    let params: BigNumParams<18, 2048> = BigNumParams::new(\n        false,\n        [\n            0x83e879145bffccbe4d783abeca8999,\n            0xb7d9868f5b915b43f6c6a8193a1a4f,\n            0x67f95badedef107f0998ab3d52961e,\n            0x7dcc9780ac8d71c6b49bbfeca25f0,\n            0xf9fdced289a3d4f62830681be65b50,\n            0x986aa8fe98888e9f609af97515b036,\n            0xd494bc65f4608849a6ed8cf5cb82ed,\n            0x18ca508b8353e676387d22667e4adb,\n            0x9d3fcb816b4763099ccbb7416a7ad,\n            0xcfd89fee1ffcfa5f2243c92e3908b7,\n            0xcaf320fbb34158238b41042f9c6386,\n            0xb3df0cd5dee269ecec61b342880c59,\n            0x2134236dc67b59df001cac48181625,\n            0x536d424ce3dcaf2b3c15eba3ceb98,\n            0x7c6532647de2f025c4245c4a816ea9,\n            0x1ca6b6ac38706f61dd460c53293c88,\n            0x812b9256f612815edb22ec614a6c89,\n            0xc9,\n        ],\n        [\n            0x9ec08341171d384b92ed35848dac43,\n            0xaa5e7059598102ad1d99f33e533781,\n            0x894978a6e54a780efd6c579b74dd3f,\n            0x9531219036eb346dc4d2f142d9aeb3,\n            0x2d67220edac65500daea360896b937,\n            0x72393de3ce76a185b8d5fe4efeb301,\n            0x2e5a676dc2d3d971ead0a1a8127ff1,\n            0xbb92e11f4b88fb1f478a8e5fcc8a63,\n            0x978205931de77dc276cbffcfa9ab06,\n            0x3f0074f27a70de9b87b38923c5d26f,\n            0x315d3964500ad7da70267bebb13aed,\n            0xee04558c06aced97c3375cb93ae624,\n            0xcaf9c90ec5317baf27dabd3f3a6018,\n            0x453a832dd0cf10c2e7669123ffdabe,\n            0xc6c46372e3eda40f2582e2e9902867,\n            0xcdb6b9ecb85a01524cbe4cee82a2c2,\n            0xbbaa5920d526e092f29b41b1c629e1,\n            0x1453,\n        ],\n    );\n    let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n        params,\n        limbs: [\n            0x2e3f7f3a3b7d89cbf680adcee4f039,\n            0xcca286445a216e1c110416099710f3,\n            0x0684d04d7773fbff2223360e314f47,\n            0x1342e7d3f7cadd18ba5f0ed57b1e54,\n            0xe5347fc80630780900cffe3d20cb7d,\n            0xda578cadd719f2a38f505d54c46203,\n            0x4a729fdd97383a0e32b5e8f671c833,\n            0x810ea2ce9ace9bd072bd3b221c9b62,\n            0xc565d6bff72c8501a729ecab2aee3b,\n            0xe042b627c4e6b4cc6ab4ca0ababaaa,\n            0x8e707750c71a4f9f0b9d9389b61826,\n            0x850297f956c58dafb6bf4f7bb049fa,\n            0x32c51e7454edae060725c509d9a48c,\n            0xbe2f1df6227e67dc61e6ab82bc501f,\n            0xea17c90cc7053bbb94ddfac6b1a405,\n            0x6c6eaada9c24dfa1a476c3718f6735,\n            0x0134b376c64ba2a79a086061573792,\n            0x22,\n        ],\n    };\n\n    assert(verify_sha256_pss(hash, signature, 2048));\n}\n","path":"/Users/ianbrighton/Documents/Mach34/open_banking/noir_rsa_pss/lib/src/rsa.nr"}},"names":["main"],"brillig_names":["__mul","__compute_quadratic_expression_with_borrow_flags","build_msg_block","attach_len_to_msg_block","build_msg_block","directive_integer_quotient","directive_to_radix"]}