{"noir_version":"1.0.0-beta.1+03b58fa2dfcc8acc8cf5198b1b23b55676fbdb02","hash":15727703735778866619,"abi":{"parameters":[{"name":"hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"signature_limbs","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"private"},{"name":"modulus_limbs","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"private"},{"name":"redc_limbs","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"private"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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NvwkG34WDZ822fCNbPhWNnzZVffuS77c8GVXXZJddUl21SXZVZdkV10vu+p62VXXy666Hjzv22Ovvv94flnowTPPvh084JM/w0fKPN8RBaRk8oEIKT98IEJa8h+IbtfOxr2foZnPTWevJKG772Fzw/ey4QfZ8KNs+Ek2/Cwaftxkwzey4VvZ8GVX3bsvz3PDl111o+yqG2VX3Si76kbZVTfJrrpJdtVNsqtuAs/7nSdWCTzzdJ5YZfCl22E/gy9d69/shwJ88KXbgw8umHvwSTZ89MTZgQ8umHvwwQVzDz562erABxfM714MO/yT5nEbetXtwEevuh346FW3Ax+96nbgo1fdDnz0qtuBj151P8GP5gwfveoeLUjsLu7P8NGrbgc+etVtwzfoVbcDH73qRv+G787w0atuBz561e3AR6+6HfjoVbcDH73qduCjV90OfPSq+4a/703O8NGr7if45vSE2Vk5e919nZ7ho1fd5vN9Z9Grbgc+etXtwEevuh346FW3Ax+96nbgo1fdDnzRL0adRa+6bfgOvep24Muuuk521XWyq+79DTN44cuuuk521UVv2dA+EOPQWza03+s69JYNPfjgl0d78MFbNvTgk2z46Fd3O/DBWzb04IO3bOjBR7843X4tjd6yoQMfvWVDDz561e3AR6+6HfjoVbcDH73qduCjV932gRiPXnXbZxo8etXtwEevuh346FW3DR+qt8nvv5aGaoRyAT561e3AR6+6HfjoVbcDH73qduCjV90OfPSq2z4QE9CrbvtATJCz1y0diInoVbf9fD+iV90OfPSq24GPXnU78NGrbgc+etXtwEevuh346FW3A190a04X0atuG36SXXWT7KqbZFfdJLvqJtlVN8muukm0HZVL4DaEkQ4TyOhPztEug9sQ9uCD2xD24IPbEPbgg9sQ9uCTbPjgNoQ9+ODmvz344Oa/n+GHc9XN4FW3B19Q1T3Dp01Q1S3BR6+6KR7wczjDR6+6HfjgVTfZw342OTrDB6+6yYQ3/ELsg1fdHnzwqtuDD151e/DBq26ifMA/n2WjDbzqduAb8Krbgw9edXvwwatuDz561e3AR6+6HfjoVbcDH73qduCjV90OfNlV18iuulZ21bWyq66VXXWt7Kp7d4eYnI8T7Tv6z2+rSuiNTS/03zpen9FH0eiTaPRZMvq7u8Mwozei0VvR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","file_map":{"6":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"18":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        /*@safety: borrow is enforced to be boolean due to its type.\n            if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n            if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n        */\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            /*@safety: decomposition is properly checked below*/\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            unsafe {\n                //@safety: already unconstrained\n                field_less_than(b, a)\n            },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            //@safety: unsafe in unconstrained\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        unsafe {\n            //@safety: Take a hint of the comparison and verify it\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"19":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            //@safety : unconstrained context\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"27":{"source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            /*@safety  : the msg_block is checked below in verify_msg_block*/\n            build_msg_block(msg, message_size, msg_start)\n        };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            //@safety : the msg_block is checked below in verify_msg_block\n            build_msg_block(msg, message_size, msg_start)\n        };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe {\n        //@safety : the msg_len is checked below in verify_msg_len\n        attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size)\n    };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::{\n        attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n        set_item_byte_then_zeros, set_item_zeros,\n    };\n    use super::INT_BLOCK;\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n\n    #[test]\n    fn test_get_item_byte() {\n        let fld = make_item(10, 20, 30, 40);\n        assert_eq(fld, 0x0a141e28);\n        assert_eq(get_item_byte(fld, 0), 10);\n        assert_eq(get_item_byte(fld, 4), 10);\n        assert_eq(get_item_byte(fld, 6), 30);\n    }\n\n    #[test]\n    fn test_byte_into_item() {\n        let fld = make_item(0, 20, 0, 0);\n        assert_eq(byte_into_item(20, 1), fld);\n        assert_eq(byte_into_item(20, 5), fld);\n    }\n\n    #[test]\n    fn test_set_item_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 0, 0, 0);\n        assert_eq(set_item_zeros(fld0, 3), fld1);\n        assert_eq(set_item_zeros(fld0, 4), 0);\n        assert_eq(set_item_zeros(0, 4), 0);\n    }\n\n    #[test]\n    fn test_set_item_byte_then_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 50, 0, 0);\n        assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_0() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48,\n        ];\n        assert_eq(input.len(), 22);\n        let (msg_block, msg_byte_ptr) = unsafe {\n            //@safety : testing context\n            build_msg_block(input, input.len(), 0)\n        };\n        assert_eq(msg_byte_ptr, input.len());\n        assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n        assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n        assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n        assert_eq(msg_block[6], 0);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_1() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        assert_eq(input.len(), 68);\n        let (msg_block, msg_byte_ptr) = unsafe {\n            //@safety : testing context\n            build_msg_block(input, input.len(), 64)\n        };\n        assert_eq(msg_byte_ptr, 4);\n        assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n        assert_eq(msg_block[1], 0);\n    }\n\n    #[test]\n    fn test_attach_len_to_msg_block() {\n        let input: INT_BLOCK = [\n            2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n            1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n            1849316213, 1651139939,\n        ];\n        let msg_block = unsafe {\n            //@safety  : testing context\n            attach_len_to_msg_block(input, 1, 448)\n        };\n        assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n        assert_eq(msg_block[1], 0);\n        assert_eq(msg_block[15], 3584);\n    }\n}\n","path":"std/hash/sha256.nr"},"62":{"source":"use bignum::{params::BigNumParams, RuntimeBigNum};\nuse rsa::{rsa::verify_sha256_pss, types::RBN2048};\n\n// Examples of the signature limbs, modulus, and redc params can be generated via\n// ../../signature_gen/main.rs.\n// Note: technically, the `signature` could've been passed into `main` directly,\n// for a much cleaner interface.\n// The reason we chose this more verbose approach here, was to reduce the amount of\n// data to generate for the Prover.toml file.\nfn main(\n    hash: [u8; 32],\n    signature_limbs: [Field; 18],\n    modulus_limbs: [Field; 18],\n    redc_limbs: [Field; 18],\n) {\n    let has_multiplicative_inverse = false;\n    let params: BigNumParams<18, 2048> =\n        BigNumParams::new(has_multiplicative_inverse, modulus_limbs, redc_limbs);\n\n    let signature: RBN2048 = RBN2048::from_array(params, signature_limbs);\n\n    assert(verify_sha256_pss(hash, signature, 2048));\n}\n\n#[test]\nfn test_main() {\n    // Output of `cargo run -- --msg \"hello world\"` in the `signature_gen` directory\n    // Create runtime params:\n    let modulus_limbs = [\n        0x83e879145bffccbe4d783abeca8999,\n        0xb7d9868f5b915b43f6c6a8193a1a4f,\n        0x67f95badedef107f0998ab3d52961e,\n        0x7dcc9780ac8d71c6b49bbfeca25f0,\n        0xf9fdced289a3d4f62830681be65b50,\n        0x986aa8fe98888e9f609af97515b036,\n        0xd494bc65f4608849a6ed8cf5cb82ed,\n        0x18ca508b8353e676387d22667e4adb,\n        0x9d3fcb816b4763099ccbb7416a7ad,\n        0xcfd89fee1ffcfa5f2243c92e3908b7,\n        0xcaf320fbb34158238b41042f9c6386,\n        0xb3df0cd5dee269ecec61b342880c59,\n        0x2134236dc67b59df001cac48181625,\n        0x536d424ce3dcaf2b3c15eba3ceb98,\n        0x7c6532647de2f025c4245c4a816ea9,\n        0x1ca6b6ac38706f61dd460c53293c88,\n        0x812b9256f612815edb22ec614a6c89,\n        0xc9,\n    ];\n    let redc_limbs = [\n        0x9ec08341171d384b92ed35848dac43,\n        0xaa5e7059598102ad1d99f33e533781,\n        0x894978a6e54a780efd6c579b74dd3f,\n        0x9531219036eb346dc4d2f142d9aeb3,\n        0x2d67220edac65500daea360896b937,\n        0x72393de3ce76a185b8d5fe4efeb301,\n        0x2e5a676dc2d3d971ead0a1a8127ff1,\n        0xbb92e11f4b88fb1f478a8e5fcc8a63,\n        0x978205931de77dc276cbffcfa9ab06,\n        0x3f0074f27a70de9b87b38923c5d26f,\n        0x315d3964500ad7da70267bebb13aed,\n        0xee04558c06aced97c3375cb93ae624,\n        0xcaf9c90ec5317baf27dabd3f3a6018,\n        0x453a832dd0cf10c2e7669123ffdabe,\n        0xc6c46372e3eda40f2582e2e9902867,\n        0xcdb6b9ecb85a01524cbe4cee82a2c2,\n        0xbbaa5920d526e092f29b41b1c629e1,\n        0x1453,\n    ];\n\n    let signature_limbs = [\n        0x2e3f7f3a3b7d89cbf680adcee4f039,\n        0xcca286445a216e1c110416099710f3,\n        0x0684d04d7773fbff2223360e314f47,\n        0x1342e7d3f7cadd18ba5f0ed57b1e54,\n        0xe5347fc80630780900cffe3d20cb7d,\n        0xda578cadd719f2a38f505d54c46203,\n        0x4a729fdd97383a0e32b5e8f671c833,\n        0x810ea2ce9ace9bd072bd3b221c9b62,\n        0xc565d6bff72c8501a729ecab2aee3b,\n        0xe042b627c4e6b4cc6ab4ca0ababaaa,\n        0x8e707750c71a4f9f0b9d9389b61826,\n        0x850297f956c58dafb6bf4f7bb049fa,\n        0x32c51e7454edae060725c509d9a48c,\n        0xbe2f1df6227e67dc61e6ab82bc501f,\n        0xea17c90cc7053bbb94ddfac6b1a405,\n        0x6c6eaada9c24dfa1a476c3718f6735,\n        0x0134b376c64ba2a79a086061573792,\n        0x22,\n    ];\n\n    // let hash: [u8; 32] = dep::std::hash::sha256(\"hello world\".as_bytes());\n    // hash of the jwt\n    let hash: [u8; 32] = [\n        190, 196, 184, 50, 102, 89, 57, 43, 211, 245, 140, 168, 170, 163, 80, 128, 25, 139, 25, 68,\n        239, 215, 154, 164, 148, 234, 47, 212, 6, 140, 157, 110,\n    ];\n\n    main(hash, signature_limbs, modulus_limbs, redc_limbs);\n}\n","path":"/Users/ianbrighton/Documents/Mach34/open_banking/noir_rsa_pss/example_pss/src/main.nr"},"64":{"source":"use crate::utils::u60_representation::U60Repr;\n\npub struct BigNumParams<let N: u32, let MOD_BITS: u32> {\n    pub has_multiplicative_inverse: bool,\n\n    // @brief modulus: all BigNum operations are evaluated modulo this value\n    pub modulus: [Field; N],\n\n    // @brief modulus but represented in a U60Repr form\n    pub modulus_u60: U60Repr<N, 2>,\n    pub modulus_u60_x4: U60Repr<N, 4>,\n\n    // @brief double_modulus: used when performing negations and subtractions\n    pub double_modulus: [Field; N],\n\n    // @brief redc_param used for __barrett_reduction. See https://en.wikipedia.org/wiki/Barrett_reduction\n    pub redc_param: [Field; N],\n}\n\n// To be implemented by the user for any BigNum they define, or within the predefined BigNums in the `fields/` dir.\npub trait BigNumParamsGetter<let N: u32, let MOD_BITS: u32> {\n    pub fn get_params() -> BigNumParams<N, MOD_BITS>;\n}\n\nimpl<let N: u32, let MOD_BITS: u32> BigNumParams<N, MOD_BITS> {\n    pub fn new(\n        has_multiplicative_inverse: bool,\n        modulus: [Field; N],\n        redc_param: [Field; N],\n    ) -> Self {\n        Self {\n            has_multiplicative_inverse,\n            modulus,\n            modulus_u60: U60Repr::from(modulus),\n            modulus_u60_x4: U60Repr::from(modulus),\n            double_modulus: get_double_modulus(modulus),\n            redc_param,\n        }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for BigNumParams<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        (self.has_multiplicative_inverse == other.has_multiplicative_inverse)\n            & (self.modulus == other.modulus)\n            & (self.modulus_u60 == other.modulus_u60)\n            & (self.modulus_u60_x4 == other.modulus_u60_x4)\n            & (self.double_modulus == other.double_modulus)\n            & (self.redc_param == other.redc_param)\n    }\n}\n\nfn get_double_modulus<let N: u32>(modulus: [Field; N]) -> [Field; N] {\n    let TWO_POW_120: Field = 0x1000000000000000000000000000000;\n    let m: U60Repr<N, 2> = U60Repr::from(modulus);\n    let mut result: [Field; N] = U60Repr::into(m + m);\n\n    result[0] += TWO_POW_120;\n    for i in 1..N - 1 {\n        result[i] += (TWO_POW_120 - 1);\n    }\n    result[N - 1] -= 1;\n    result\n}\n","path":"/Users/ianbrighton/nargo/github.com/noir-lang/noir-bignum/v0.5.0/src/params.nr"},"65":{"source":"use crate::utils::split_bits;\n\nuse crate::fns::{\n    constrained_ops::validate_quotient_in_range, unconstrained_helpers::__barrett_reduction,\n};\nuse crate::params::BigNumParams as P;\n\n/**\n * In this file:\n *\n * __compute_quadratic_expression_with_borrow_flags\n * __add_linear_expression\n * __compute_quadratic_expression_product\n * __compute_quadratic_expression\n * evaluate_quadratic_expression\n */\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\nunconstrained fn __compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([Field; N], [Field; N], [Field; 2 * N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut mulout_p = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let modulus: [Field; N] = params.modulus;\n    let modulus_bits = MOD_BITS;\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        modulus_bits,\n        modulus,\n        params.modulus_u60_x4,\n    );\n    assert(remainder == [0; N]);\n\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] * modulus[j];\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N] = [0; 2 * N];\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    let downshift: Field = 1 / two_pow_120;\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits = (mulout_p[0] - mulout_n[0] + (borrow_flags[0] * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field =\n            mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (\n            mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n                - (borrow_flags[i - 1] * borrow_carry)\n        )\n            * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n    flags: [bool; M],\n) -> ([Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [Field; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [Field; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + modulus2[j] - x[i][j];\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn __compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut add: [Field; N] = [0; N];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [Field; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] * rhs[k][j]);\n            }\n        }\n        mulout[i] += add[i];\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\npub(crate) unconstrained fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([Field; N], [Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        k,\n        params.modulus,\n        params.modulus_u60_x4,\n    );\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([Field; N], [Field; N], [Field; 2 * N]) = unsafe {\n        __compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [Field; N] = params.double_modulus;\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i];\n                    t0[k][i] += double_modulus[i];\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i];\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i];\n                    t1[k][i] += double_modulus[i];\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i];\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i];\n                t4[i] += double_modulus[i];\n            } else {\n                t4[i] += linear_terms[j][i];\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term = t0[k][i] * t1[k][j] - quotient[i] * params.modulus[j];\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j];\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] * params.modulus[j];\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size::<1>();\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size::<1>();\n        product_limbs[i] += (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n","path":"/Users/ianbrighton/nargo/github.com/noir-lang/noir-bignum/v0.5.0/src/fns/expressions.nr"},"66":{"source":"use crate::params::BigNumParams as P;\n\nuse crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__div, __mul, __udiv_mod},\n};\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n */\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [Field; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        std::hash::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[Field; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [Field; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n        let mut num_remaining_limbs =\n            (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n        let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n        let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n            + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n        for j in 0..num_limbs_in_bigfield {\n            let mut limb: Field = 0;\n            for _ in 0..15 {\n                let need_more_bytes = (byte_ptr < num_bytes);\n                let mut byte = hash_buffer[byte_ptr];\n                limb *= (256 * need_more_bytes as Field + (1 - need_more_bytes as Field));\n                limb += byte as Field * need_more_bytes as Field;\n                byte_ptr += need_more_bytes as u32;\n            }\n            bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n        }\n        bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n    }\n\n    let mut bigfield_rhs_limbs: [Field; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [Field; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n    result\n}\n\n/**\n* @brief conditional_select given the value of `predicate` return either `self` (if 0) or `other` (if 1)\n* @description should be cheaper than using an IF statement (TODO: check!)\n**/\npub(crate) fn conditional_select<let N: u32>(\n    lhs: [Field; N],\n    rhs: [Field; N],\n    predicate: bool,\n) -> [Field; N] {\n    let mut result: [Field; N] = lhs;\n    for i in 0..N {\n        result[i] = (lhs[i] - rhs[i]) * predicate as Field + rhs[i];\n    }\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    let modulus = params.modulus;\n    for i in 0..N {\n        l *= two_pow_120;\n        r *= two_pow_120;\n        modulus_mod_n *= two_pow_120;\n        l += lhs[N - i - 1];\n        r += rhs[N - i - 1];\n        modulus_mod_n += modulus[N - i - 1];\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let mut diff = l - r;\n    let mut target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let mut is_equal_modulus: bool = true;\n    let mut is_equal_zero: bool = true;\n    for i in 0..N {\n        is_equal_modulus = is_equal_modulus & (diff[i] == params.modulus[i]);\n        is_equal_zero = is_equal_zero & (diff[i] == 0);\n    }\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [Field; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = modulus[i] - val[i];\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    p_minus_self[0] += borrow_flags[0] as Field * two_pow_120;\n    for i in 1..N - 1 {\n        p_minus_self[i] += (borrow_flags[i] as Field * two_pow_120 - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= borrow_flags[N - 2] as Field;\n    let mut compare = val;\n    compare = p_minus_self;\n    validate_in_range::<_, MOD_BITS>(compare);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N - 1) {\n        limbs[i].assert_max_bit_size::<120>();\n    }\n    limbs[N - 1].assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N) {\n        limbs[i].assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    limbs[N - 1].assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [Field; N], rhs: [Field; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (result, carry_flags, borrow_flags) = unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, MOD_BITS>(result);\n\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let carry_shift = 0x1000000000000000000000000000000;\n\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] - rhs[0] + addend[0] - result[0] - 1\n        + (borrow_flags[0] as Field * borrow_shift)\n        - (carry_flags[0] as Field * carry_shift);\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - borrow_flags[i - 1] as Field\n            + carry_flags[i - 1] as Field\n            + ((borrow_flags[i] as Field - carry_flags[i] as Field) * borrow_shift);\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] - rhs[N - 1] + addend[N - 1]\n        - result[N - 1]\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [Field; N] {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    let (result, borrow_flags) = unsafe { __neg_with_flags(params, val) };\n    validate_in_range::<_, MOD_BITS>(result);\n    let modulus = params.modulus;\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let result_limb = modulus[0] - val[0] - result[0] + (borrow_flags[0] as Field * borrow_shift);\n    assert(result_limb == 0);\n    for i in 1..N - 1 {\n        let result_limb = modulus[i] - val[i] - result[i] - borrow_flags[i - 1] as Field\n            + (borrow_flags[i] as Field * borrow_shift);\n        assert(result_limb == 0);\n    }\n    let result_limb = modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as Field;\n    assert(result_limb == 0);\n    result\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    let (result, carry_flags, borrow_flags, overflow_modulus) =\n        unsafe { __add_with_flags(params, lhs, rhs) };\n    validate_in_range::<_, MOD_BITS>(result);\n    let modulus = params.modulus;\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let carry_shift = 0x1000000000000000000000000000000;\n\n    let mut subtrahend: [Field; N] = [0; N];\n    if (overflow_modulus) {\n        subtrahend = modulus;\n    }\n    let result_limb = lhs[0] + rhs[0] - subtrahend[0] - result[0]\n        + (borrow_flags[0] as Field * borrow_shift)\n        - (carry_flags[0] as Field * carry_shift);\n    assert(result_limb == 0);\n    for i in 1..N - 1 {\n        let result_limb = lhs[i] + rhs[i] - subtrahend[i] - result[i] - borrow_flags[i - 1] as Field\n            + carry_flags[i - 1] as Field\n            + ((borrow_flags[i] as Field - carry_flags[i] as Field) * borrow_shift);\n        assert(result_limb == 0);\n    }\n    let result_limb = lhs[N - 1] + rhs[N - 1]\n        - subtrahend[N - 1]\n        - result[N - 1]\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n    result\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (result, carry_flags, borrow_flags, underflow) =\n        unsafe { __sub_with_flags(params, lhs, rhs) };\n    validate_in_range::<_, MOD_BITS>(result);\n    let modulus = params.modulus;\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let carry_shift = 0x1000000000000000000000000000000;\n\n    let mut addend: [Field; N] = [0; N];\n    if (underflow) {\n        addend = modulus;\n    }\n    let result_limb = lhs[0] - rhs[0] + addend[0] - result[0]\n        + (borrow_flags[0] as Field * borrow_shift)\n        - (carry_flags[0] as Field * carry_shift);\n    assert(result_limb == 0);\n    for i in 1..N - 1 {\n        let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - borrow_flags[i - 1] as Field\n            + carry_flags[i - 1] as Field\n            + ((borrow_flags[i] as Field - carry_flags[i] as Field) * borrow_shift);\n        assert(result_limb == 0);\n    }\n    let result_limb = lhs[N - 1] - rhs[N - 1] + addend[N - 1]\n        - result[N - 1]\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n    result\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    evaluate_quadratic_expression(\n        params,\n        [[lhs]],\n        [[false]],\n        [[rhs]],\n        [[false]],\n        [result],\n        [true],\n    );\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    evaluate_quadratic_expression(\n        params,\n        [[result]],\n        [[false]],\n        [[rhs]],\n        [[false]],\n        [lhs],\n        [true],\n    );\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n\n    // self / divisor = quotient rounded\n    // quotient * divisor + remainder - self = 0\n    evaluate_quadratic_expression(\n        params,\n        [[quotient]],\n        [[false]],\n        [[divisor]],\n        [[false]],\n        [numerator, remainder],\n        [true, false],\n    );\n    // we need (remainder < divisor)\n    // implies (divisor - remainder > 0)\n    validate_gt::<_, MOD_BITS>(divisor, remainder);\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor \n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n\n","path":"/Users/ianbrighton/nargo/github.com/noir-lang/noir-bignum/v0.5.0/src/fns/constrained_ops.nr"},"67":{"source":"/**\n* @brief construct a BigNum instance out of an array of bytes in BIG ENDIAN format\n* @description: each 120-bit limb represents 15 bytes, we require that the size of the byte array\n*               is precisely large enough to cover MOD_BITS\n* @param x: input byte array\n**/\npub(crate) fn from_be_bytes<let N: u32, let MOD_BITS: u32, let NBytes: u32>(\n    x: [u8; NBytes],\n) -> [Field; N] {\n    let num_bits = NBytes * 8;\n    assert(num_bits >= MOD_BITS);\n    assert(num_bits - MOD_BITS < 8);\n    let mut result = [0; N];\n\n    let excess_bytes = N * 15 - NBytes;\n    let final_limb_bytes = 15 - excess_bytes;\n    let mut limb: Field = 0;\n    let mut k = 0;\n    for _j in 0..final_limb_bytes {\n        limb *= 256;\n        limb += x[k] as Field;\n        k += 1;\n    }\n    result[N - 1] = limb;\n\n    for i in 1..N {\n        let mut limb: Field = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as Field;\n            k += 1;\n        }\n        result[N - i - 1] = limb;\n    }\n\n    let most_significant_byte: Field = x[0] as Field;\n\n    most_significant_byte.assert_max_bit_size::<8 - (NBytes * 8 - MOD_BITS)>();\n    result\n}\n\npub(crate) fn to_le_bytes<let N: u32, let MOD_BITS: u32, let NBytes: u32>(\n    val: [Field; N],\n) -> [u8; NBytes] {\n    let nbytes = (MOD_BITS / 8) + (MOD_BITS % 8 != 0) as u32;\n    assert(nbytes <= NBytes);\n\n    let mut result: [u8; NBytes] = [0; NBytes];\n    for i in 0..N - 1 {\n        let limb_bytes: [u8; 15] = val[i].to_le_bytes();\n        for j in 0..15 {\n            result[i * 15 + j] = limb_bytes[j];\n        }\n    }\n    let last_limb_bytes: [u8; 15] = val[N - 1].to_le_bytes();\n    let num_last_bytes = (NBytes - (N - 1) * 15);\n    for i in 0..num_last_bytes {\n        result[(N - 1) * 15 + i] = last_limb_bytes[i];\n    }\n    result\n}\n","path":"/Users/ianbrighton/nargo/github.com/noir-lang/noir-bignum/v0.5.0/src/fns/serialization.nr"},"69":{"source":"use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __multiplicative_generator, __primitive_root_log_size,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse crate::utils::u60_representation::U60Repr;\n\n/**\n * In this file:\n *\n * __one\n * __derive_from_seed\n * __eq\n * __is_zero\n * __neg\n * __add\n * __sub\n * __mul_with_quotient\n * __mul\n * __div\n * __udiv_mod\n * __invmod\n * __pow\n * __batch_invert\n * __batch_invert_slice\n */\n\npub(crate) unconstrained fn __one<let N: u32>() -> [Field; N] {\n    let mut limbs: [Field; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [Field; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [Field; N], rhs: [Field; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [Field; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    limbs: [Field; N],\n) -> [Field; N] {\n    let f: [Field; N] = limbs;\n    let x_u60: U60Repr<N, 2> = U60Repr::from(f);\n    U60Repr::into(params.modulus_u60 - x_u60)\n}\n\npub(crate) unconstrained fn __add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let x_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let y_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let mut z_u60 = x_u60 + y_u60;\n\n    if z_u60.gte(params.modulus_u60) {\n        z_u60 = z_u60 - params.modulus_u60;\n    }\n    U60Repr::into(z_u60)\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    __add(params, lhs, __neg(params, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += lhs[i] * rhs[j];\n        }\n    }\n    let to_reduce = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(\n        to_reduce,\n        params.redc_param,\n        MOD_BITS,\n        params.modulus,\n        params.modulus_u60_x4,\n    );\n\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    let inv_divisor = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let mut quotient_u60: U60Repr<N, 2> = U60Repr::from([0; N]);\n    let mut remainder_u60: U60Repr<N, 2> = U60Repr::from(numerator);\n\n    let mut divisor_u60: U60Repr<N, 2> = U60Repr::from(divisor);\n    let b = divisor_u60;\n\n    let mut bit_difference = remainder_u60.get_msb() - divisor_u60.get_msb();\n\n    let mut accumulator_u60: U60Repr<N, 2> = U60Repr::one();\n    divisor_u60 = divisor_u60.shl(bit_difference);\n    accumulator_u60 = accumulator_u60.shl(bit_difference);\n\n    if (divisor_u60.gte(remainder_u60 + U60Repr::one())) {\n        divisor_u60.shr1();\n        accumulator_u60.shr1();\n    }\n    for _ in 0..(N * 120) {\n        if (remainder_u60.gte(b) == false) {\n            break;\n        }\n\n        // we've shunted 'divisor' up to have the same bit length as our remainder.\n        // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n        if (remainder_u60.gte(divisor_u60)) {\n            remainder_u60 -= divisor_u60;\n            // we can use OR here instead of +, as\n            // accumulator is always a nice power of two\n            quotient_u60 = quotient_u60 + accumulator_u60;\n        }\n        divisor_u60.shr1(); // >>= 1;\n        accumulator_u60.shr1(); //  >>= 1;\n    }\n\n    (U60Repr::into(quotient_u60), U60Repr::into(remainder_u60))\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [Field; N] {\n    let one: [Field; N] = __one::<N>();\n    let one_u60: U60Repr<N, 2> = U60Repr::from(one);\n    let exp_u60 = params.modulus_u60 - (one_u60 + one_u60);\n    let exp = U60Repr::into(exp_u60);\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n    exponent: [Field; N],\n) -> [Field; N] {\n    let x: U60Repr<N, 2> = U60Repr::from(exponent);\n\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [Field; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if x.get_bit(num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn __batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n) -> [[Field; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut result: [[Field; N]; M] = [[0; N]; M];\n    let mut temporaries: [[Field; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (__is_zero(x[i]) == false) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    let mut T0: [Field; N] = [0; N];\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (__is_zero(x[idx]) == false) {\n            T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]],\n) -> [[Field; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut result: [[Field; N]] = [[0; N]];\n    let mut temporaries: [[Field; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (__is_zero(x[i]) == false) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n        result = result.push_back([0; N]);\n    }\n\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    let mut T0: [Field; N] = [0; N];\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (__is_zero(x[idx]) == false) {\n            T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [Field; N],\n) -> std::option::Option<[Field; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one_u60: U60Repr<N, 2> = unsafe { U60Repr::one() };\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let mut Q = (params.modulus_u60 - one_u60).shr(primitive_root_log_size - 1);\n    let Q_minus_one_over_two_u60 = (Q - one_u60).shr(2);\n    let Q_minus_one_over_two: [Field; N] = U60Repr::into(Q_minus_one_over_two_u60);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [Field; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut found_root = false;\n    let one: [Field; N] = __one::<N>();\n    if (__eq(check, one) == false) {} else {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                found_root = true;\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    let result = if found_root {\n        std::option::Option::some(r)\n    } else {\n        std::option::Option::none()\n    };\n    result\n}\n","path":"/Users/ianbrighton/nargo/github.com/noir-lang/noir-bignum/v0.5.0/src/fns/unconstrained_ops.nr"},"70":{"source":"use crate::utils::split_bits;\nuse crate::utils::u60_representation::U60Repr;\n\nuse crate::fns::unconstrained_ops::{__add, __eq, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\n\nglobal TWO_POW_60: u64 = 0x1000000000000000;\n\n/**\n * In this file:\n *\n * __validate_in_field_compute_borrow_flags\n * __validate_gt_remainder\n * __neg_with_flags\n * __add_with_flags\n * __sub_with_flags\n * __barrett_reduction\n * __tonelli_shanks_sqrt\n */\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [Field; N] = params.modulus;\n    flags[0] = modulus[0].lt(val[0]);\n    for i in 1..N - 1 {\n        flags[i] = modulus[i].lt(val[i] + flags[i - 1] as Field);\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N]) {\n    let a_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let mut b_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let underflow = b_u60.gte(a_u60);\n    b_u60 += U60Repr::one();\n    assert(underflow == false, \"BigNum::validate_gt check fails\");\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = b_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            if (carry & borrow == 1) {\n                carry = 0;\n                borrow = 0;\n            }\n            carry_flags[i / 2] = carry as bool;\n            borrow_flags[i / 2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> ([Field; N], [bool; N]) {\n    let x_u60: U60Repr<N, 2> = U60Repr::from(val);\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut borrow_in: u64 = 0;\n\n    let mut borrow_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let sub_term = x_u60.limbs[i] + borrow_in;\n        let borrow = (sub_term > params.modulus_u60.limbs[i]) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + params.modulus_u60.limbs[i] - sub_term;\n\n        borrow_in = borrow;\n        if ((i & 1) == 1) {\n            borrow_flags[i / 2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let b_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n    let add_u60 = a_u60 + b_u60;\n\n    let overflow = add_u60.gte(params.modulus_u60);\n\n    let mut subtrahend_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    if overflow {\n        subtrahend_u60 = params.modulus_u60;\n    }\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + b_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = subtrahend_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            let idx = (i - 1) / 2;\n            if (carry & borrow == 1) {\n                carry = 0;\n                borrow = 0;\n            }\n            carry_flags[idx] = carry as bool;\n            borrow_flags[idx] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let b_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let underflow = b_u60.gte(a_u60 + U60Repr::one());\n\n    let addend_u60: U60Repr<N, 2> = if underflow {\n        params.modulus_u60\n    } else {\n        U60Repr { limbs: [0; 2 * N] }\n    };\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + addend_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = b_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            if (carry & borrow == 1) {\n                carry = 0;\n                borrow = 0;\n            }\n            carry_flags[i / 2] = carry as bool;\n            borrow_flags[i / 2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [Field; 2 * N],\n    redc_param: [Field; N],\n    k: u32,\n    modulus: [Field; N],\n    modulus_u60: U60Repr<N, 4>,\n) -> ([Field; N], [Field; N]) {\n    // for each i in 0..(N + N), adds x[i] * redc_param[j] to mulout[i + j] for each j in 0..N\n    let mut mulout: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout[i + j] += x[i] * redc_param[j];\n        }\n    }\n\n    mulout = split_bits::__normalize_limbs(mulout, 3 * N - 1);\n    let mulout_u60: U60Repr<N, 6> = U60Repr::new(mulout);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient_u60 = mulout_u60.shr((k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient_full should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = quotient_u60.into_field_array();\n\n    // quotient_mul_modulus_normalized can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n\n    // First, accumulate the products into quotient_mul_modulus_normalized\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus_normalized[i + j] += partial_quotient_full[i] * modulus[j];\n        }\n    }\n\n    // Then, split the accumulated values and propagate higher bits\n    for i in 0..(N + N) {\n        let (lo, hi) = split_bits::split_120_bits(quotient_mul_modulus_normalized[i]);\n        quotient_mul_modulus_normalized[i] = lo;\n\n        // Propagate higher bits to the next index\n        // TODO: what is faster, leaving this if statement in or out?\n        // (array is size-1 too large so we can tolerate adding 0 into max element)\n        if (i + 1 < N + N) {\n            quotient_mul_modulus_normalized[i + 1] += hi;\n        }\n    }\n\n    let quotient_mul_modulus_u60: U60Repr<N, 4> = U60Repr::new(quotient_mul_modulus_normalized);\n    // convert the input into U60Repr\n    let x_u60: U60Repr<N, 4> = U60Repr::new(x);\n    let mut remainder_u60 = x_u60 - quotient_mul_modulus_u60;\n    // barrett reduction is quircky so might need to remove a few modulus_u60 from the remainder\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    } else {}\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n\n    let q: [Field; N] = U60Repr::into(quotient_u60);\n    let r: [Field; N] = U60Repr::into(remainder_u60);\n\n    (q, r)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut target: U60Repr<N, 2> = params.modulus_u60 - U60Repr::one();\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target.limbs[0] & 1) == 1;\n        if (!lsb_is_one) {\n            result += 1;\n            target.shr1();\n        } else {\n            break;\n        }\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [Field; N],\n    p_minus_one_over_two: [Field; N],\n) -> (bool, [Field; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [Field; N] = __one();\n    let neg_one = __neg(params, one);\n    let found = __eq(exped, neg_one);\n    let mut result: (bool, [Field; N]) = (found, target);\n    if (!found) {\n        let _target = unsafe { __add(params, target, one) };\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [Field; N] {\n    let mut target: [Field; N] = __one();\n    let p_minus_one_over_two: U60Repr<N, 2> = (params.modulus_u60 - U60Repr::one()).shr(1);\n    let p_minus_one_over_two: [Field; N] = U60Repr::into(p_minus_one_over_two);\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [Field; N],\n    i: u32,\n) -> u32 {\n    let one: [Field; N] = __one();\n    let is_one = __eq(t2m, one);\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n","path":"/Users/ianbrighton/nargo/github.com/noir-lang/noir-bignum/v0.5.0/src/fns/unconstrained_helpers.nr"},"74":{"source":"global TWO_POW_56: u64 = 0x100000000000000;\nglobal TWO_POW_60: u64 = 0x1000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 120 bit fields\npub unconstrained fn split_120_bits(mut x: Field) -> (Field, Field) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_56 = ((x as u64) % TWO_POW_56) as Field;\n\n    let low = low_lower_64 + TWO_POW_64 * low_upper_56;\n    let high = (x - low_upper_56) / TWO_POW_56 as Field;\n\n    (low, high)\n}\n\n/**\n * @brief Decomposes a single field into two 60 bit fields\n *\n * @description Expects the input limb to be in the range [0, ..., 2^{120 - 1}]\n **/\npub unconstrained fn split_60_bits(x: Field) -> (u64, u64) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let x_lower_64 = (x as u64);\n    let low = x_lower_64 % TWO_POW_60;\n    let high = ((x - (low as Field)) / TWO_POW_60 as Field) as u64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [Field; N] {\n    let mut normalized: [Field; N] = [0; N];\n    let mut inp: _ = input;\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(inp[i]);\n\n        normalized[i] = lo;\n        inp[i + 1] += hi;\n    }\n    {\n        let (lo, hi) = split_120_bits(inp[range - 1]);\n        normalized[range - 1] = lo;\n        assert(hi == 0);\n    }\n    normalized\n}\n","path":"/Users/ianbrighton/nargo/github.com/noir-lang/noir-bignum/v0.5.0/src/utils/split_bits.nr"},"75":{"source":"use crate::utils::msb::get_msb64;\nuse crate::utils::split_bits;\n\n/**\n * @brief U60Repr represents a BigNum element as a sequence of 60-bit unsigned integers.\n *\n * @description: used in unconstrained functions when computing witness values.\n * It is helpful to use u60 types when evaluating addition operations that can overflow the field modulus,\n * as well as when performing bit shifts.\n */\npub struct U60Repr<let N: u32, let NumSegments: u32> {\n    pub(crate) limbs: [u64; N * NumSegments],\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Add for U60Repr<N, NumSegments> {\n    fn add(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut carry: u64 = 0;\n        for i in 0..N * NumSegments {\n            let mut add: u64 = self.limbs[i] + b.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            result.limbs[i] = add;\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Sub for U60Repr<N, NumSegments> {\n    fn sub(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut borrow: u64 = 0;\n        let mut borrow_in: u64 = 0;\n\n        for i in 0..N * NumSegments {\n            borrow = ((b.limbs[i] + borrow_in) > self.limbs[i]) as u64;\n            let sub = (borrow << 60) + self.limbs[i] - b.limbs[i] - borrow_in;\n            result.limbs[i] = sub;\n            borrow_in = borrow;\n        }\n\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::convert::From<[Field; N]> for U60Repr<N, NumSegments> {\n    fn from(input: [Field; N]) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..(N) {\n            let (lo, hi) = unsafe { split_bits::split_60_bits(input[i]) };\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::convert::Into<[Field; N]> for U60Repr<N, NumSegments> {\n    fn into(x: U60Repr<N, NumSegments>) -> [Field; N] {\n        let mut result: [Field; N] = [0; N];\n        let two_pow_60: Field = 0x1000000000000000;\n        for i in 0..N {\n            result[i] = x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * two_pow_60);\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::cmp::Eq for U60Repr<N, NumSegments> {\n    fn eq(self, other: Self) -> bool {\n        self.limbs == other.limbs\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> U60Repr<N, NumSegments> {\n\n    pub(crate) unconstrained fn new<let NumFieldSegments: u32>(\n        x: [Field; N * NumFieldSegments],\n    ) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..(N * NumFieldSegments) {\n            let (lo, hi) = split_bits::split_60_bits(x[i]);\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn one() -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        result.limbs[0] = 1;\n        result\n    }\n\n    pub(crate) unconstrained fn into_field_array(\n        x: U60Repr<N, NumSegments>,\n    ) -> [Field; N * NumSegments / 2] {\n        let mut result: [Field; N * NumSegments / 2] = [0; N * NumSegments / 2];\n        let two_pow_60: Field = 0x1000000000000000;\n        for i in 0..(N * NumSegments / 2) {\n            result[i] = x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * two_pow_60);\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn gte(self, b: Self) -> bool {\n        let mut result = false;\n        let mut early_exit = false;\n        for i in 0..(N * NumSegments) {\n            if (b.limbs[(N * NumSegments) - 1 - i] < self.limbs[((N * NumSegments) - 1 - i)]) {\n                result = true;\n                early_exit = true;\n                break;\n            } else if (\n                b.limbs[(N * NumSegments) - 1 - i] != self.limbs[((N * NumSegments) - 1 - i)]\n            ) {\n                result = false;\n                early_exit = true;\n                break;\n            }\n        }\n        if (early_exit == false) {\n            result = (self.limbs[0] == b.limbs[0]);\n        }\n        result\n    }\n\n    pub(crate) fn get_bit(self, bit: u32) -> bool {\n        let segment_index = bit / 60;\n        let uint_index = bit % 60;\n\n        let limb: u64 = self.limbs[segment_index];\n        let value = (limb >> uint_index as u8) & 1;\n        value == 1\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = shift % 60;\n        let remainder_shift = 60 - limb_shift;\n        let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n        result.limbs[0] = (self.limbs[0 + num_shifted_limbs] >> limb_shift as u8);\n\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i + num_shifted_limbs];\n            result.limbs[i] = (value >> limb_shift as u8);\n            let remainder: u64 = (value << remainder_shift as u8) & mask;\n            result.limbs[i - 1] = result.limbs[i - 1] + remainder;\n        }\n        result\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr1(&mut self) {\n        let value = self.limbs[NumSegments * N - 1];\n        self.limbs[NumSegments * N - 1] = value >> 1;\n\n        let mut remainder = (value & 1) << 59;\n\n        for i in 0..N * NumSegments {\n            let value = self.limbs[N * NumSegments - 1 - i];\n            self.limbs[N * NumSegments - 1 - i] = (value >> 1) + remainder;\n            remainder = (value << 59) & 0x800000000000000;\n        }\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shl(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; NumSegments * N] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = (shift % 60) as u8;\n        let remainder_shift: u8 = 60 - limb_shift as u8;\n\n        // 83\n        // limb shift = 1\n        // inside shift = 19 bits to the left\n        // meaning we have 19 carry bits and 41 remainder bits\n        let mask: u64 = (1 as u64 << 60) - 1;\n        //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n        let value = self.limbs[0];\n\n        let mut remainder = (value >> remainder_shift);\n        result.limbs[num_shifted_limbs] = (value << (limb_shift as u8)) & mask;\n\n        // shift 84. num shifted = 1\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i];\n            let upshift = ((value << (limb_shift as u8)) + remainder) & mask;\n            result.limbs[i + num_shifted_limbs] = upshift;\n            remainder = (value >> remainder_shift);\n            // let remainder: u64 = (self.limbs.get(i + num_shifted_limbs as u64) << remainder_shift as u8) & mask;\n            // result.limbs.set(i - 1, result.limbs.get(i - 1) + remainder);\n        }\n        result\n    }\n\n    pub(crate) fn increment(&mut self) {\n        let mut carry: u64 = 0;\n\n        let mut add: u64 = self.limbs[0] + 1;\n        carry = add >> 60;\n        add = add - (carry << 60);\n        self.limbs[0] = add;\n\n        for i in 1..NumSegments * N {\n            let mut add: u64 = self.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            self.limbs[i] = add;\n        }\n    }\n\n    pub(crate) unconstrained fn get_msb(val: Self) -> u32 {\n        let mut count = 0;\n        for i in 0..N * NumSegments {\n            let v = val.limbs[((N * NumSegments) - 1 - i)];\n            if (v > 0) {\n                count = 60 * ((N * NumSegments) - 1 - i) + get_msb64(v);\n                break;\n            }\n        }\n        count\n    }\n}\n","path":"/Users/ianbrighton/nargo/github.com/noir-lang/noir-bignum/v0.5.0/src/utils/u60_representation.nr"},"110":{"source":"use crate::params::BigNumParams;\nuse crate::utils::map::map;\n\nuse crate::fns::{\n    constrained_ops::{\n        add, assert_is_not_equal, conditional_select, derive_from_seed, div, eq, mul, neg, sub,\n        udiv, udiv_mod, umod, validate_in_field, validate_in_range,\n    },\n    expressions::{__compute_quadratic_expression, evaluate_quadratic_expression},\n    serialization::{from_be_bytes, to_le_bytes},\n    unconstrained_ops::{\n        __add, __batch_invert, __batch_invert_slice, __derive_from_seed, __div, __eq, __invmod,\n        __is_zero, __mul, __neg, __pow, __sub, __tonelli_shanks_sqrt, __udiv_mod,\n    },\n};\nuse std::ops::{Add, Div, Mul, Neg, Sub};\n\npub struct RuntimeBigNum<let N: u32, let MOD_BITS: u32> {\n    pub limbs: [Field; N],\n    pub params: BigNumParams<N, MOD_BITS>,\n}\n\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNum<N, MOD_BITS> {}\n\n// All functions prefixed `__` are unconstrained!\n// They're not actually decorated as `unconstrained` because to return the `params` (as part of Self) from an `unconstrained` fn would cause range constraints. Instead, each `__` fn wraps a call to an unconstrained fn, so that the already-range-constrained `params` can be inserted into Self after the unconstrained call.\npub(crate) trait RuntimeBigNumTrait<let N: u32, let MOD_BITS: u32>: Neg + Add + Sub + Mul + Div + Eq {\n    pub fn new(params: BigNumParams<N, MOD_BITS>) -> Self;\n    pub fn one(params: BigNumParams<N, MOD_BITS>) -> Self;\n    pub fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self;\n    pub fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self;\n    pub fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [Field]) -> Self;\n    pub fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [Field; N]) -> Self;\n    pub fn from_be_bytes<let NBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        x: [u8; NBytes],\n    ) -> Self;\n\n    pub fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes];\n\n    pub fn modulus(self) -> Self;\n    pub fn modulus_bits() -> u32;\n    pub fn num_limbs() -> u32;\n    // pub fn get(self) -> [Field];\n    pub fn get_limbs(self) -> [Field; N];\n    pub fn get_limb(self, idx: u32) -> Field;\n    pub fn set_limb(&mut self, idx: u32, value: Field);\n\n    unconstrained fn __eq(self, other: Self) -> bool;\n    unconstrained fn __is_zero(self) -> bool;\n\n    // unconstrained\n    pub fn __neg(self) -> Self;\n    // unconstrained\n    pub fn __add(self, other: Self) -> Self;\n    // unconstrained\n    pub fn __sub(self, other: Self) -> Self;\n    // unconstrained\n    pub fn __mul(self, other: Self) -> Self;\n    // unconstrained\n    pub fn __div(self, other: Self) -> Self;\n    // unconstrained\n    pub fn __udiv_mod(self, divisor: Self) -> (Self, Self);\n    // unconstrained\n    pub fn __invmod(self) -> Self;\n    // unconstrained\n    pub fn __pow(self, exponent: Self) -> Self;\n\n    // unconstrained\n    pub fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M];\n    unconstrained fn __batch_invert_slice<let M: u32>(to_invert: [Self]) -> [Self];\n\n    pub fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self>;\n\n    // unconstrained\n    pub fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self);\n\n    pub fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    );\n\n    pub fn eq(lhs: Self, rhs: Self) -> bool {\n        lhs == rhs\n    }\n    pub fn assert_is_not_equal(self, other: Self);\n    pub fn validate_in_field(self);\n    pub fn validate_in_range(self);\n    // pub fn validate_gt(self, lhs: Self, rhs: Self);\n\n    pub fn udiv_mod(numerator: Self, divisor: Self) -> (Self, Self);\n    pub fn udiv(numerator: Self, divisor: Self) -> Self;\n    pub fn umod(numerator: Self, divisor: Self) -> Self;\n\n    pub fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self;\n}\n\nimpl<let N: u32, let MOD_BITS: u32> Neg for RuntimeBigNum<N, MOD_BITS> {\n    fn neg(self) -> Self {\n        let params = self.params;\n        Self { limbs: neg::<_, MOD_BITS>(params, self.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNumTrait<N, MOD_BITS> for RuntimeBigNum<N, MOD_BITS> {\n\n    fn new(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let limbs: [Field; N] = [0; N];\n        Self { limbs, params }\n    }\n\n    fn one(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let mut result = RuntimeBigNum::new(params);\n        result.limbs[0] = 1;\n        result\n    }\n\n    fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = unsafe { derive_from_seed::<_, MOD_BITS, _>(params, seed) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = unsafe { __derive_from_seed::<_, MOD_BITS, _>(params, seed) };\n        Self { limbs, params }\n    }\n\n    fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [Field]) -> Self {\n        Self { limbs: limbs.as_array(), params }\n    }\n\n    fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [Field; N]) -> Self {\n        Self { limbs, params }\n    }\n\n    fn from_be_bytes<let NBytes: u32>(params: BigNumParams<N, MOD_BITS>, x: [u8; NBytes]) -> Self {\n        Self { limbs: from_be_bytes::<_, MOD_BITS, _>(x), params }\n    }\n\n    fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes] {\n        to_le_bytes::<_, MOD_BITS, _>(self.limbs)\n    }\n\n    fn modulus(self) -> Self {\n        let params = self.params;\n        Self { limbs: params.modulus, params }\n    }\n\n    fn modulus_bits() -> u32 {\n        MOD_BITS\n    }\n\n    fn num_limbs() -> u32 {\n        N\n    }\n\n    // fn get(self) -> [Field] {\n    //     self.get_limbs()\n    // }\n\n    fn get_limbs(self) -> [Field; N] {\n        self.limbs\n    }\n\n    fn get_limb(self, idx: u32) -> Field {\n        self.limbs[idx]\n    }\n\n    fn set_limb(&mut self, idx: u32, value: Field) {\n        self.limbs[idx] = value;\n    }\n\n    unconstrained fn __eq(self, other: Self) -> bool {\n        assert(self.params == other.params);\n        __eq(self.limbs, other.limbs)\n    }\n\n    unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __neg(self) -> Self {\n        let params = self.params;\n        let limbs = unsafe { __neg(params, self.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __add(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __sub(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __mul::<_, MOD_BITS>(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        let limbs = unsafe { __div::<_, MOD_BITS>(params, self.limbs, divisor.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = unsafe { __udiv_mod(self.limbs, divisor.limbs) };\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __invmod(self) -> Self {\n        let params = self.params;\n        assert(params.has_multiplicative_inverse);\n        let limbs = unsafe { __invmod::<_, MOD_BITS>(params, self.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __pow(self, exponent: Self) -> Self {\n        let params = self.params;\n        assert(params == exponent.params);\n        let limbs = unsafe { __pow::<_, MOD_BITS>(params, self.limbs, exponent.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs =\n            unsafe { __batch_invert::<_, MOD_BITS, _>(params, x.map(|bn| Self::get_limbs(bn))) };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // Note: can't return a slice from this unconstrained to a constrained function.\n    unconstrained fn __batch_invert_slice<let M: u32>(x: [Self]) -> [Self] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs = unsafe {\n            let inv_slice =\n                __batch_invert_slice::<_, MOD_BITS>(params, x.map(|bn| Self::get_limbs(bn)));\n            inv_slice.as_array()\n        };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self> {\n        let params = self.params;\n        let maybe_limbs = unsafe { __tonelli_shanks_sqrt(params, self.limbs) };\n        maybe_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self) {\n        let (q_limbs, r_limbs) = unsafe {\n            __compute_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n                params,\n                map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                lhs_flags,\n                map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                rhs_flags,\n                map(linear_terms, |bn| Self::get_limbs(bn)),\n                linear_flags,\n            )\n        };\n        (Self { limbs: q_limbs, params }, Self { limbs: r_limbs, params })\n    }\n\n    fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) {\n        evaluate_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            rhs_flags,\n            map(linear_terms, |bn| Self::get_limbs(bn)),\n            linear_flags,\n        )\n    }\n\n    fn validate_in_field(self: Self) {\n        let params = self.params;\n        validate_in_field::<_, MOD_BITS>(params, self.limbs);\n    }\n\n    fn validate_in_range(self) {\n        validate_in_range::<_, MOD_BITS>(self.limbs);\n    }\n\n    fn assert_is_not_equal(self, other: Self) {\n        let params = self.params;\n        assert(params == other.params);\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = udiv_mod::<_, MOD_BITS>(params, self.limbs, divisor.limbs);\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    fn udiv(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: udiv::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    fn umod(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: umod::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self {\n        let params = lhs.params;\n        assert(params == rhs.params);\n        Self { limbs: conditional_select(lhs.limbs, rhs.limbs, predicate), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Add for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: add::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Sub for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: sub::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Mul for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: mul::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Div for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: div::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for RuntimeBigNum<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        let params = self.params;\n        assert(params == other.params);\n        eq::<_, MOD_BITS>(params, self.limbs, other.limbs)\n    }\n}\n","path":"/Users/ianbrighton/nargo/github.com/noir-lang/noir-bignum/v0.5.0/src/runtime_bignum.nr"},"114":{"source":"use dep::bignum::{params::BigNumParams, RuntimeBigNum};\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature to the original message hash\n * @details Taken from https://github.com/richardliang/noir-rsa\n **/\nfn compare_signature_sha256<let N: u32>(padded_sha256_hash: [u8; N], msg_hash: [u8; 32]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    // NOTE: Assume MAX_BYTES < 2^32 bit number. MAX_BYTES of 259 > 2^8 bits so need to cast it to u32\n    for i in 0..32 {\n        // Padded hash is reversed\n        assert(padded_sha256_hash[31 - i] == msg_hash[i]);\n    }\n\n    let hash_prefix: [u8; 19] =\n        [32, 4, 0, 5, 1, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 49, 48];\n\n    for i in 32..51 {\n        assert(hash_prefix[i - 32] == padded_sha256_hash[i]);\n    }\n\n    assert(padded_sha256_hash[51] == 0);\n\n    // Sub 32 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 54;\n    for i in 52..N {\n        if i < 52 + ps_len {\n            // PS padding which depends on RSA modulus / sig length. 1024 bits = 128 bytes = 128 - 54 = 74 bytes of 0xFF padding\n            assert(padded_sha256_hash[i] == 255);\n        } else if i == 52 + ps_len {\n            // Pad 0x01\n            assert(padded_sha256_hash[i] == 1);\n        } else if i == 53 + ps_len {\n            // 0x00\n            assert(padded_sha256_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha256_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Verify an RSA signature generated via the pkcs1v15 signature scheme.\n * @note The `exponent` can be either 65537 or 3 (i.e. the most common values in use for RSA)\n * Rough cost: 2,048 bit RSA: 26,888 gates per verification\n *             1,024 bit RSA: 11,983 gates per verification\n * A circuit that verifies 1 signature (and does nothing else) will cost ~32k due to initialization costs of lookup tables\n **/\npub fn verify_sha256_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    assert((exponent == 3) | (exponent == 65537), \"Exponent must be 65537 or 3\");\n    let mut exponentiated = sig * sig; // sig^2\n    if exponent == 65537 {\n        // e = 65537 = 1 0000 0000 0000 0001\n        exponentiated = exponentiated * exponentiated; // sig^4\n        exponentiated = exponentiated * exponentiated; // sig^8\n        exponentiated = exponentiated * exponentiated; // sig^16\n        exponentiated = exponentiated * exponentiated; // sig^32\n        exponentiated = exponentiated * exponentiated; // sig^64\n        exponentiated = exponentiated * exponentiated; // sig^128\n        exponentiated = exponentiated * exponentiated; // sig^256\n        exponentiated = exponentiated * exponentiated; // sig^512\n        exponentiated = exponentiated * exponentiated; // sig^1024\n        exponentiated = exponentiated * exponentiated; // sig^2048\n        exponentiated = exponentiated * exponentiated; // sig^4096\n        exponentiated = exponentiated * exponentiated; // sig^8192\n        exponentiated = exponentiated * exponentiated; // sig^16384\n        exponentiated = exponentiated * exponentiated; // sig^32768\n        exponentiated = exponentiated * exponentiated; // sig^65536\n    }\n    // otherwise, e = 3 = 11\n    exponentiated = exponentiated * sig; // either sig^2 * sig = sig^3 or sig^65536 * sig = sig^65537\n    let mut padded_sha256_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha256(padded_sha256_hash_bytes, msg_hash)\n}\n\npub fn verify_sha256_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    key_size: u32,\n) -> bool {\n    // Exponentiate the signature assuming e = 65537\n    let mut exponentiated = sig * sig;\n    for _ in 0..15 {\n        exponentiated = exponentiated * exponentiated;\n    }\n    exponentiated = exponentiated * sig;\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; ModBits / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = key_size - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (key_size + 7) / 8;\n    let h_len = 32;\n    let s_len = 32;\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L242\n    let offset = key_len - em_len;\n    // As the hash is 32 bytes and we also remove the 0xBC at the end, we have up to NumBytes - 33 bytes left for DB\n    // For example, for 2048 bit RSA (i.e. 256 bytes), we have 256 - 33 = 223 bytes left for DB\n    // and for 1024 bit RSA (i.e. 128 bytes), we have 128 - 33 = 95 bytes left for DB\n    let masked_db: [u8; (ModBits / 8) - 33] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L205\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1\n    let db_mask: [u8; (ModBits / 8) - 33] = mgf1_sha256(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits / 8) - 33];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 32] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 72]; // 8 + h_len + s_len\n    for i in 8..40 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 40..72 {\n        m_prime[i] = salt[i - 40];\n    }\n\n    // Compute H'\n    let h_prime = dep::std::hash::sha256(m_prime);\n\n    // Compare H and H'\n    h == h_prime\n}\n\nfn reverse_array<let N: u32>(array: [u8; N]) -> [u8; N] {\n    let mut reversed = [0 as u8; N];\n    for i in 0..N {\n        reversed[i] = array[N - i - 1];\n    }\n    reversed\n}\n\nfn get_array_slice<let N: u32, let M: u32>(array: [u8; N], start: u32, end: u32) -> [u8; M] {\n    assert(end - start <= M);\n    let mut slice = [0 as u8; M];\n    for i in 0..M {\n        if i < end - start {\n            slice[i] = array[start + i];\n        }\n    }\n    slice\n}\n\nfn pow(base: u32, exp: u32) -> u32 {\n    let mut result = 1;\n    for _ in 0..exp {\n        result *= base;\n    }\n    result\n}\n\nglobal HASH_LEN: u32 = 32;\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA256 as the hash function\n **/\nfn mgf1_sha256<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * HASH_LEN\n    std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * HASH_LEN as Field + 1);\n\n    // HASH_LEN bytes are added at each iteration and there is at least 1 iteration\n    // so if HASH_LEN is not enough to fill MASK_LEN bytes in one iteration,\n    // another one is required and so on.\n    let iterations = (MASK_LEN / HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; HASH_LEN] = [0; HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        // Hash the block\n        // First SEED_LEN bytes are the seed, next 4 bytes are the counter\n        hashed = dep::std::hash::sha256_var(block, SEED_LEN as u64 + 4);\n\n        // Copy hashed output to mask\n        for j in 0..HASH_LEN {\n            if i * HASH_LEN + j < MASK_LEN {\n                mask[i * HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n#[test]\nfn test_verify_sha256_pkcs1v15_1024() {\n    // Output of `cargo run -- --msg \"hello world! test#123\" --bits 1024` in the `signature_gen` directory\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"hello world! test#123\".as_bytes());\n    assert(\n        sha256_hash\n            == [\n                220, 155, 229, 143, 122, 133, 55, 215, 75, 44, 132, 111, 57, 33, 248, 84, 213, 170,\n                193, 96, 253, 57, 124, 13, 251, 42, 92, 147, 105, 172, 233, 85,\n            ],\n    );\n\n    let params: BigNumParams<9, 1024> = BigNumParams::new(\n        false,\n        [\n            0xab238ad9cb37979a43aefbf10be8fb,\n            0x31347febe45fe8c2dac1dd30900704,\n            0xa5a9a6b9cd0cc2b9d13bbd4e068263,\n            0x5eac6390f7873fe97ff9bb14a173ea,\n            0xbc41f700c91fd733a2c63177bbdbd4,\n            0x41442bd58769a3595b659a2ec9c6be,\n            0x4ddc91395f330382aa2e2d3fbe147,\n            0x3d008ff255a0bc71c7887f5728ba1,\n            0xb640c3a8f511c64e,\n        ],\n        [\n            0x5d53d2634c6a0918266043968ce263,\n            0x5dd4be3dce0323a492ee9340aec4db,\n            0xf82d0e2e5c8319f01a460c72c01854,\n            0x236e6fc6e62e8a1d522acda5fb3892,\n            0xdaf755619d66e580901aa224d03174,\n            0x8366291616480e7e1f202dbcedda87,\n            0x40ba1202537d1e94561ccc05265586,\n            0x69b993d857ba89ea5de9822aeb4b93,\n            0x167968c0000761a273,\n        ],\n    );\n\n    let signature: RuntimeBigNum<9, 1024> = RuntimeBigNum {\n        params,\n        limbs: [\n            0xc3850e84ea02da3f028ff422f4d6a9,\n            0x9761f0bd9021f76d45c60df0670a19,\n            0xc1ede421a43607ab623ed4d5a17fc8,\n            0x86197b4315206f4d53200b42555831,\n            0xe95783b69db28c26a83706f39d04cd,\n            0x18b178dc1a9ec76fb22b57e4dfa703,\n            0xdd0e19cd5a09ab48e7af4d0e3470e3,\n            0x10004dfab1cf91304e80e6baa4dfc7,\n            0x241c3fd77b90adef,\n        ],\n    };\n\n    assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n}\n\n#[test]\nfn test_verify_sha256_pkcs1v15_2048() {\n    // Output of `cargo run -- --msg \"Hello World! This is Noir-RSA\"` in the `signature_gen` directory\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"Hello World! This is Noir-RSA\".as_bytes());\n    assert(\n        sha256_hash\n            == [\n                91, 207, 46, 60, 22, 153, 217, 144, 2, 127, 224, 143, 181, 45, 32, 120, 122, 131,\n                166, 79, 166, 183, 43, 158, 116, 105, 73, 207, 196, 77, 33, 5,\n            ],\n    );\n\n    let params: BigNumParams<18, 2048> = BigNumParams::new(\n        false,\n        [\n            0x8d5e7d9daedd6cfd1c9bdf0227e05b,\n            0xbfb937fc4d3cf02cc0af780f3cab44,\n            0xd20637ef7adcf5d238ee87bccc9bca,\n            0xb9db4f2663108e2f8b673f7612ae8b,\n            0x85f894ef669b36bfd3d86b0a28873,\n            0xdcc70e1884e38b8229cce3b884121d,\n            0x35488d1138e0b03e1676f7f5d8a5b3,\n            0xe1a97820e7dcbb4eab35c9b71bb273,\n            0x97d19eb3c63249ddbfcff915863f54,\n            0x3a78c7af6da0f6af0d67b1ca4b6065,\n            0xd7a3c433c020f624821e5e678c7d69,\n            0x52d5b53240feae82ffea3d2a3d9b09,\n            0xb8aad5e19e2163f68997c6fdd71906,\n            0x5db432d06e8b0bf59511100c7894e2,\n            0xadc0bbc4c54da10d1cc88438ea3127,\n            0xece1cf6a1501109cd2734d5893c8d9,\n            0x7196b90acdf06c31b1288064fd0c27,\n            0xc8,\n        ],\n        [\n            0x1b1deccf4dbde852c34a5d6908a0f,\n            0xbc9e5bdab22f023fbcca58692bccf5,\n            0x1f65439685623e45396ff55751c3bf,\n            0x2b6ad2c5f8e3aac15d0ccbab816bfa,\n            0x5ca2e8e3048243c16c708a8030ab0d,\n            0x30079bfeb1fa51e5501581173ca19c,\n            0xff8d5f6bea485fdcc2716327f69ab4,\n            0x36b599d81589416b5b5f037986b999,\n            0x75612e34a4ff29f0a19a7823512f58,\n            0x288b6897929b54c3b26a5faa07c00f,\n            0x4b5675fa13ab7444f1f047d3eb1bbe,\n            0x6ba0ac610ef9f267ab30fe25bb1c84,\n            0xa386b48ee03168d5cea3ecb9dc901f,\n            0xacf1a01f7dba44e050c976142fb1f6,\n            0x97a63b5cb7efc60d3502946aec63cf,\n            0x12cc1d5cab10a1e9e2398d29b9e3ef,\n            0x4635cf25c66e76bba8034df46204fb,\n            0x146f,\n        ],\n    );\n\n    let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n        params,\n        limbs: [\n            0xad29e07d16a278de49a371b9760a27,\n            0x86311920cc0e17a3c20cdff4c56dbb,\n            0x863556c6c5247dd83668dd825716ae,\n            0xc247c960945f4485b46c33b87425ca,\n            0x7326463c5c4cd5b08e21b938d9ed9a,\n            0x4f89fe0c82da08a0259eddb34d0da1,\n            0x43a74e76d4e1bd2666f1591889af0d,\n            0x240f7b80f0ff29f4253ee3019f832d,\n            0xc6edd131fbaaf725fd423dac52b362,\n            0x85f9732679242163e8afff44f6104d,\n            0xd3c3bbcb1757013fd6fb80f31dd9a6,\n            0x9008633f15df440e6df6d21ee585a2,\n            0x324df3425ed256e283be5b6b761741,\n            0xc60c1302929bd0e07caa4aeff4e8fd,\n            0x600d804ff13ba8d0e1bc9508714212,\n            0x50f7e75e5751d7edd61167027926be,\n            0x0db41d39442023e1420a8a84fe81d9,\n            0xab,\n        ],\n    };\n    assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n}\n\n#[test]\nfn test_verify_sha256_pkcs1v15_2048_exponent_3() {\n    // Output of `cargo run -- --msg \"hello world\" -e 3` in the `signature_gen` directory\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"hello world\".as_bytes());\n    assert(\n        sha256_hash\n            == [\n                185, 77, 39, 185, 147, 77, 62, 8, 165, 46, 82, 215, 218, 125, 171, 250, 196, 132,\n                239, 227, 122, 83, 128, 238, 144, 136, 247, 172, 226, 239, 205, 233,\n            ],\n    );\n\n    let params: BigNumParams<18, 2048> = BigNumParams::new(\n        false,\n        [\n            0xe40ee47801326543c8e84b85d567c1,\n            0x5b54ea87f0ce29de1995697b0696fd,\n            0x457078f8fdce68b437cac0970b2452,\n            0x473ec776fee3731b6ab06e35875ddc,\n            0x62dedd594e5f12c80c3ccb5791a6cd,\n            0xecb934b9d8272c5e3a418145345499,\n            0xd1af643b3d785470ed0c6cd633f706,\n            0xb58a57b9e96eccbdfc7c17f0333d4,\n            0x2ebd34b5039fc596504927c282c60d,\n            0x3a44928a74f25fc1043bb37ce4dfa8,\n            0x91448459f9617fac33a2816162ac9e,\n            0x70cb910d9f3e1a78864640ec6c8240,\n            0x9aed33f6b31f1c9de67248a98c180,\n            0x7f1416e032c79488c94b311e87bd9c,\n            0x7191b4ebb1b3fffa949fa48ed01e5,\n            0x350a75cbaeca6bfdd71ca83cdbcae9,\n            0xfb1d274fa207457c6814d42c09f9cf,\n            0xd4,\n        ],\n        [\n            0x803bf4d38110a7d37fdd05f590dee9,\n            0xa68d317c933f37cab5ab4e7c00a3b9,\n            0x476a05a536bf5f2aa1b8850146cba7,\n            0xca297ea8b5528d91d4836ff27c30ab,\n            0x75cf2eaab76eefa12bbd570f1aea9f,\n            0x8f6a8ab877d9c5bcd98c37bdc5c2d3,\n            0xd497db1f6ebe83decacaa647fabea6,\n            0x686b27ca330e25e7a7cf197f6433ef,\n            0xfde04d2225c8308b07580af0058a0f,\n            0xa29fb69777c0e916976243b2b09855,\n            0xf983592285852e7e1c2cb3ae968323,\n            0x673608017f9f5acf67a01b73728d70,\n            0xeeff82521c0bc432a05f4b7444fac0,\n            0x85a89c4d229f60aaa3aa7ac7dac1e2,\n            0xcfecff93bc9fbfe0d6dff6091f2db8,\n            0xf20f047dcb224b4447bd098c07f8c2,\n            0x554bb53cadeb3eaab911a189f90227,\n            0x133b,\n        ],\n    );\n\n    let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n        params,\n        limbs: [\n            0xa250eff812c63eaaeaa3f04641c05f,\n            0xecc09613cb8b289c1f37c8f92e6a05,\n            0x2c0a0510058360c07af65d46f594fd,\n            0x943d67513363d3de430c94a1dafe7c,\n            0x511ec8e9b10bc6c6ff0d6c232ccf92,\n            0x50ffd07b3c093b3f5fc027de847731,\n            0xc268e1489449943fdafdf89ff168c3,\n            0x0b8b7f9f49b492f78fda58d252f23a,\n            0x491c6c4ef836a6a8730b7bf81e865e,\n            0x8746c75fb079d014e419543f56d7f0,\n            0x65804c417d6168a8bc0025d255cebf,\n            0xf695e91b77890b8e3fd775fa56e627,\n            0x5e90001c0218550f4083ae28025a2f,\n            0x526bd4eff34f25f62a698f0470e0a6,\n            0x7f224306a7d9daf536b1559434c6c6,\n            0x88809f16fe1fcea3c87511d9319735,\n            0x7694685fee0bfab4a9196b92ec6f2e,\n            0xa7,\n        ],\n    };\n\n    assert(verify_sha256_pkcs1v15(sha256_hash, signature, 3));\n}\n\n#[test]\nfn test_mgf1_sha256() {\n    let seed: [u8; 32] = dep::std::hash::sha256(\"Hello World! This is Noir-RSA\".as_bytes());\n    let expected_mask: [u8; 32] = [\n        106, 93, 232, 46, 236, 203, 51, 228, 103, 104, 145, 29, 197, 74, 26, 194, 135, 200, 40, 232,\n        179, 172, 220, 135, 51, 185, 209, 35, 194, 131, 176, 190,\n    ];\n    let mask: [u8; 32] = mgf1_sha256(seed);\n    assert(mask == expected_mask);\n}\n\n#[test]\nfn test_verify_sha256_pss_2048() {\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"Hello World! This is Noir-RSA\".as_bytes());\n\n    let params: BigNumParams<18, 2048> = BigNumParams::new(\n        false,\n        [\n            0x45648f4ade2ac1f40c18b44a2951ad,\n            0xd558cced315cbced65532e416ab0ea,\n            0x67c3818b41ed79f0e9e06b10b31a39,\n            0x9bb9db99001fe165b2a18bfb8ff423,\n            0xc792c2037f2abe206bdc987898a73b,\n            0x6630acf8743e8ffca5199b195d2e32,\n            0xbffc9f0464184da3de5f0efa5a705b,\n            0xe14bd49bd3ec93d8f3e84f47a32e6d,\n            0x2d6abfec39882cd67f7804b9ff278e,\n            0x1140883fa39129d297ebee534cdf58,\n            0x96bc387e08849589aa1dda5d381cd2,\n            0x31c60ecdf4d3c1119814b724779a9e,\n            0x1a4882267e3e2e6074b40448d62087,\n            0x9e015854d57eae42e5b515d357a755,\n            0xb593f8dfc8434f32d7d30277b1abc,\n            0x4e7184b54966a30552fc92df470aa,\n            0xa8a3c9172762978b03464671f8288e,\n            0xba,\n        ],\n        [\n            0x1c63831dbaa98693ab59ca2ae5a88,\n            0x3e67cf06ca2556701f3aa8d158552,\n            0x7c63171078a831165ed8b2dd116675,\n            0x9e1f1bca55d0e220e58ddbbb387972,\n            0xd7c72f20722cc7af897d5819424801,\n            0xf0434a631cffe4c4d56874bff93661,\n            0x8767e83f45cfff15cca95d5dc6f48c,\n            0xf210d697748e9ad45c0f7c3ed3bda8,\n            0xc960d59cb9dd48d50e12c2ef04dda2,\n            0xbf07cf1ecc532686848dca09d061c2,\n            0xc491a60be200f9574ad6aa31977a4f,\n            0x67681170f25ab2aff941b18e21e1bd,\n            0xc485fc6deda1ba84f2bfcfbea2c044,\n            0x776bc3eac3728ec7f85ca2496ee8e4,\n            0x4d82eeb8ecdc1ec53280fce96c05e,\n            0x514088d39ff1cae50d2f67db91458f,\n            0x9c1553de9eef61a83b288c4d11610e,\n            0x15f1,\n        ],\n    );\n\n    let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n        params,\n        limbs: [\n            0xcce57aaed9eed21edef9d96d9ebdf8,\n            0x181f152657736ea458462ff45b1d81,\n            0x9df8c00fefe67c3a727c1f84641d2a,\n            0xe3bb299609d4f4bfe7e979123f6962,\n            0x6cf987c686983f184262419dc8d64b,\n            0xedc086f713d60c9d661a4e7fdae380,\n            0xb95ada34d5b9217d9eaa89d1d7a3d1,\n            0xec275d1d4e3e74296eab26318df81f,\n            0x3c943e2d3e12f1394952de70d92ac9,\n            0x4a4e8a625138a533b9b71cbb03c991,\n            0xa5379dfc363e79c5a55ad71a01948e,\n            0x9340e047e0d4be67ac7f1517fe2673,\n            0xdf2606ac8cbbcad391c5e925bf5082,\n            0x249690032f10b7986e7edbb8ec0d6a,\n            0x8c07da4fbed69ab71f127fb5edf73c,\n            0x64aefd403b6a4353ebdc9b7fce82bc,\n            0x5ecc107633bc4cc1a3adb545b474de,\n            0x7b,\n        ],\n    };\n\n    assert(verify_sha256_pss(sha256_hash, signature, 2048));\n}\n\n#[test]\nfn test_verify_sha256_pss_4096() {\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"Hello World! This is Noir-RSA\".as_bytes());\n    let params: BigNumParams<35, 4096> = BigNumParams::new(\n        false,\n        [\n            0xa6222b52f49e7258fe4fee04ea2d9,\n            0x2fd64c9fce4dba1e003e9b0947ee34,\n            0xf46a24f43be90f258013ba55794c6a,\n            0xda8100ed967a7577f4144295e37b68,\n            0x8545db58ed5cb1a78661a725c2e2df,\n            0xfc1673fba9882dc0c1bf1ebd95e9a7,\n            0xf8863f5481969b504d93ec7b3634f,\n            0xafedf06a9d7583f1c06b2ee8a1f2b8,\n            0x375c3f57b70cb7fc6b934445a97ebe,\n            0xd89ad291b95a70bf4922b45d2efff8,\n            0x2bf000f6408944083d93e45030e827,\n            0xf55cb42313719c7a2bfa07b3eb1ed4,\n            0x6d8656a0f3b41fa1a717140dc5ce90,\n            0x404b10d983681bd3f9ed1534d5bfa2,\n            0xced48aead2b9ba16f08a0fb968a96c,\n            0x43acf088910c3322f7da5c2d0a2211,\n            0x58b7e2d7b7f268eb990fc464defe90,\n            0x2be3be3a4fedf432a98dda3c220958,\n            0xf9156a2bafb69ef294360c25d22759,\n            0x1b7e6763845875a1886345b4ee8940,\n            0xa40ae130e9762120841e1930873975,\n            0x2d883272a543cf8fd0cdfbecc94367,\n            0x715a88142fec78eb472f6684cd942d,\n            0xdd302fea25298915e2db875f6ab621,\n            0x6612ced822df9c00c368466391fe23,\n            0x48acb5eea186585b9c24443397b8fb,\n            0x53fc8b5e2bedc30b81f632371f1e8a,\n            0x7ef026faeb670fc44abfeee192bec6,\n            0xb07bb4bfb19773a319052ffac029a9,\n            0x81c21e9e538893cb04debde34bc02e,\n            0x823427edc35eaf0a2f5d493318db74,\n            0xbad02f47a1ff078d0103affc3792b1,\n            0xe297eab3b3edafcf99c2ba52cb8424,\n            0x3e7e575d40629a07980fa71996e807,\n            0xc27a,\n        ],\n        [\n            0x54aba16603d87dec091aa1821ce3b0,\n            0x8f6a9c560fe4f4d5fb83999853bd1c,\n            0x4d9b41fcc316ae6b1a9bb7eefa7713,\n            0x623fcac3bfa0aa5f932acc0f0f28c9,\n            0xb29eca15e9ba6d9bbcd2ac543f9558,\n            0x43689b8fe8bbb48269c2fb3b03a624,\n            0xc6f8b1cbefb4cb7d2eec1bc951808b,\n            0x4074a7837f67403f497133fee0e29,\n            0x536ba97fd34f92aae1e0354bc17db0,\n            0x784c203e438e43ddddae491fd0c0e9,\n            0xf41ae3f5f5060d212bcc7c4ee71d2,\n            0xe539fd3b39a98377199ae15d165ea,\n            0xd13be03a50e9694c4c84e2541303ed,\n            0x38136b8771f62c9778e1f812ceadec,\n            0x23bea00ab5c2efafde2c8ea46673a8,\n            0xa4d3523ba9389da81c46adde61fece,\n            0xadb3053369bb6e7233eea01174caa2,\n            0x68995fa9f373e420a9f6e6fa2329e7,\n            0x38f83f074d3ee3674e7336349a0d4e,\n            0xd9ecb79c431b08a695e4808a636a48,\n            0x3498c268b8bb4936c9e8f9fa73da27,\n            0x123ed10b1358dde62125f1191fc922,\n            0xa5a412e4c3c73dbb5cba119c48af2d,\n            0xbee3217219d507e4a6ff74b9b9eee5,\n            0x2ee5efcaee7ca45ffcd85f10eeb21b,\n            0xb977bc65277e5723737f52905837bc,\n            0xd1fd3aa6e7717bceccf73b04c8bf2d,\n            0x7964355f3acd61d2408ce20a964740,\n            0xfc2e76f487e6ca0e6bcadbf9d3801d,\n            0xfb0ea20336cf95062efb880d82cab5,\n            0x6884d9ca882e37df90f8f5c603b7b1,\n            0x9be945fc633fcc0dd2b84ec1debef5,\n            0x8d834cbc2c9a3aa4a85a3994bc569d,\n            0x7055060035c122b095b75e6de37d48,\n            0x150fc2,\n        ],\n    );\n    let signature: RuntimeBigNum<35, 4096> = RuntimeBigNum {\n        params,\n        limbs: [\n            0xdeb402a595b32a248fd427ed84c743,\n            0x75f1b3656f2eb61c3e4164375052cf,\n            0x33aa80998875b8b48263611706607b,\n            0xd9c80be79f586e80ac3af1a8d5ea53,\n            0xf0b116fd85546f206ae49d041d0223,\n            0x406a397f56e62863aa7b6ed1429dec,\n            0xd7e0bbd7ac00a419f3fef0098e904f,\n            0x303665df221e3691c84c6502d1b807,\n            0xb2ce0e36df94a88f8120b53a0bcb84,\n            0xe8e55991ffdb5b731b77cb249991d1,\n            0xbaa946c3acb9696a4d416d86291fd2,\n            0x7746a7486603b1cfb5dc5f800ee409,\n            0x567d9470319309142967b699404091,\n            0x5ee6fbb50c8637805ec6c7780a9e0a,\n            0x32bf8a51bc178cdb664ca911c857ea,\n            0xe928146ddcc0865c10215611955243,\n            0x5d12083acd2e3a1b7f7313dea0b894,\n            0x8620f5ba7615db0a3285c735813a73,\n            0x7b84f0e392902e84792c4879f48fbc,\n            0x1437df81c544ea4d7fdb020bfb7fcb,\n            0x09fb8b36d3a58a6a5fff27c1664d97,\n            0xef70898862d34d8f2d7c1bb1fb8103,\n            0xd24f625196ae71e3064596a7dd80f3,\n            0xeb646b3e5958fc213a0f711a5c68c4,\n            0x7f57a200d1894a07a33610c56a543d,\n            0xa54baf3fadfe09f896d2f2c88df7e7,\n            0xb605122c80e189236329bbf9ad6c9f,\n            0xa6ac0b396215d0f50b3705cd08788a,\n            0xdad6946e3c27a25ab484a0ed338788,\n            0x874dfd4c3723c395217a881b93283a,\n            0xf5ac1d98a50f59a40db4e2d4864a07,\n            0x9d6ed5b0d10028a291588a3359cd32,\n            0x7d8b67a1bad38a5ec750dc27bc8ae0,\n            0xa2ddd25f61adf97f5e2e8a0ef99ba8,\n            0x2244,\n        ],\n    };\n    assert(verify_sha256_pss(sha256_hash, signature, 4096));\n}\n\n// doesnt work yet need better method\n// #[test]\nfn test_verify_sha256_pss_1964() {\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"Hello World! This is Noir-RSA\".as_bytes());\n    let params: BigNumParams<17, 1964> = BigNumParams::new(\n        false,\n        [\n            0xe62ce4613d178a8af9154a28c804c9,\n            0xe9c80bb90ee949aa26d5554f5b7323,\n            0xa823c32e66dce57c7617704f092c82,\n            0x8b7eee92772e414a23ee9dd5ef843a,\n            0x6590039cb62daeea7a96faf674175c,\n            0x2905f4400973a1442181701f12f30d,\n            0xc5f0a37929848a5fbe070ddc915dee,\n            0x2ada1490d935ef7700c43dc2565539,\n            0xa99acb3b526abb963d71e527c17e2e,\n            0xf9d79341476659c231dc93313fb440,\n            0x168d8abd0528fa146b6401034358f2,\n            0x6d7386e7d66bec5392a463d34f7b5d,\n            0xeb245f85612f76849ce32cd5f9011e,\n            0x2d171c40f36f34eeb17b4643c7f9e2,\n            0xd582273cf4c5fb0c195ccac1526478,\n            0x1df64d0a6c95698d34c1b16640ad92,\n            0xdd8e29ecdc0,\n        ],\n        [\n            0x7893f159b37d9b4d46e77e420d3315,\n            0x97913c7ea0db74a13b793686c0fa,\n            0x3eddab2786c599e1fcd99b06a1b151,\n            0x6f922b72a2386f483d35d5017ef102,\n            0xcf9ede21d4ca70a045ccdac95c1e9,\n            0xbe7c0cc79955f74eafb82000838e19,\n            0x26bd0fc82288bde663f5dff239b55b,\n            0x95f857821550531b848b454b4f7dc7,\n            0xef08d9d594fbf1547ac00a03323aa7,\n            0x3bb9f9263bfe85814477c58de4934d,\n            0x214887fd218e3573f1aae50917a816,\n            0xe6f1abc97678adf59b2008645d8802,\n            0x28dd35618649eef12941db95081242,\n            0xc13764316f70444e7120b6ae5088f5,\n            0xefb1aba9512f1b2c88db34a4938796,\n            0x6aed9a143fb37749eca936a60ae25c,\n            0x127ccb9568ee6,\n        ],\n    );\n\n    let signature: RuntimeBigNum<17, 1964> = RuntimeBigNum {\n        params,\n        limbs: [\n            0x37c3a3f915fb9e787412d457ec4a63,\n            0xd60918c40b6c50bcc8afa8d1ea754f,\n            0x98eec8d63deeb22eca4f9d15b7e935,\n            0xc841db8c9930934dcc8171a5fee4b4,\n            0x3341bdb96ed1d734959e257dbc85ca,\n            0x32701c7557ca04c15cd9e18f45d37b,\n            0xefd3dae979f5a920654dc7a3ea2277,\n            0x1d6724ec09b112e8776c115874a53f,\n            0xf403d3593f85b9ab421fa26bf99298,\n            0x04e85e3628f4c3fc254a92c56ba0b8,\n            0x975bb82f1fe3c3d1656e098682f69f,\n            0x0ad72d532c8e6e17398d918c360973,\n            0xc4ba256370766c633e77d4102a8919,\n            0xc4d3bb32bc889aca394bef272d3f71,\n            0x5d56778a3d1ad3117471d4060761b0,\n            0x5fd5d71fec72f615614d6347935f35,\n            0x09ab8ab67e43,\n        ],\n    };\n    assert(verify_sha256_pss(sha256_hash, signature, 4096));\n\n}\n\n#[test]\nfn test_verify_sha256_pss_jwt() {\n    let hash: [u8; 32] = [\n        190, 196, 184, 50, 102, 89, 57, 43, 211, 245, 140, 168, 170, 163, 80, 128, 25, 139, 25, 68,\n        239, 215, 154, 164, 148, 234, 47, 212, 6, 140, 157, 110,\n    ];\n    let params: BigNumParams<18, 2048> = BigNumParams::new(\n        false,\n        [\n            0x83e879145bffccbe4d783abeca8999,\n            0xb7d9868f5b915b43f6c6a8193a1a4f,\n            0x67f95badedef107f0998ab3d52961e,\n            0x7dcc9780ac8d71c6b49bbfeca25f0,\n            0xf9fdced289a3d4f62830681be65b50,\n            0x986aa8fe98888e9f609af97515b036,\n            0xd494bc65f4608849a6ed8cf5cb82ed,\n            0x18ca508b8353e676387d22667e4adb,\n            0x9d3fcb816b4763099ccbb7416a7ad,\n            0xcfd89fee1ffcfa5f2243c92e3908b7,\n            0xcaf320fbb34158238b41042f9c6386,\n            0xb3df0cd5dee269ecec61b342880c59,\n            0x2134236dc67b59df001cac48181625,\n            0x536d424ce3dcaf2b3c15eba3ceb98,\n            0x7c6532647de2f025c4245c4a816ea9,\n            0x1ca6b6ac38706f61dd460c53293c88,\n            0x812b9256f612815edb22ec614a6c89,\n            0xc9,\n        ],\n        [\n            0x9ec08341171d384b92ed35848dac43,\n            0xaa5e7059598102ad1d99f33e533781,\n            0x894978a6e54a780efd6c579b74dd3f,\n            0x9531219036eb346dc4d2f142d9aeb3,\n            0x2d67220edac65500daea360896b937,\n            0x72393de3ce76a185b8d5fe4efeb301,\n            0x2e5a676dc2d3d971ead0a1a8127ff1,\n            0xbb92e11f4b88fb1f478a8e5fcc8a63,\n            0x978205931de77dc276cbffcfa9ab06,\n            0x3f0074f27a70de9b87b38923c5d26f,\n            0x315d3964500ad7da70267bebb13aed,\n            0xee04558c06aced97c3375cb93ae624,\n            0xcaf9c90ec5317baf27dabd3f3a6018,\n            0x453a832dd0cf10c2e7669123ffdabe,\n            0xc6c46372e3eda40f2582e2e9902867,\n            0xcdb6b9ecb85a01524cbe4cee82a2c2,\n            0xbbaa5920d526e092f29b41b1c629e1,\n            0x1453,\n        ],\n    );\n    let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n        params,\n        limbs: [\n            0x2e3f7f3a3b7d89cbf680adcee4f039,\n            0xcca286445a216e1c110416099710f3,\n            0x0684d04d7773fbff2223360e314f47,\n            0x1342e7d3f7cadd18ba5f0ed57b1e54,\n            0xe5347fc80630780900cffe3d20cb7d,\n            0xda578cadd719f2a38f505d54c46203,\n            0x4a729fdd97383a0e32b5e8f671c833,\n            0x810ea2ce9ace9bd072bd3b221c9b62,\n            0xc565d6bff72c8501a729ecab2aee3b,\n            0xe042b627c4e6b4cc6ab4ca0ababaaa,\n            0x8e707750c71a4f9f0b9d9389b61826,\n            0x850297f956c58dafb6bf4f7bb049fa,\n            0x32c51e7454edae060725c509d9a48c,\n            0xbe2f1df6227e67dc61e6ab82bc501f,\n            0xea17c90cc7053bbb94ddfac6b1a405,\n            0x6c6eaada9c24dfa1a476c3718f6735,\n            0x0134b376c64ba2a79a086061573792,\n            0x22,\n        ],\n    };\n\n    assert(verify_sha256_pss(hash, signature, 2048));\n}\n","path":"/Users/ianbrighton/Documents/Mach34/open_banking/noir_rsa_pss/lib/src/rsa.nr"}},"names":["main"],"brillig_names":["split_60_bits","__mul","__compute_quadratic_expression_with_borrow_flags","build_msg_block","attach_len_to_msg_block","build_msg_block","directive_integer_quotient","directive_to_radix"]}